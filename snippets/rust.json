{
  "v": {
    "prefix": "v",
    "body": [
      "let mut ${1:name} = vec![${2}];"
    ],
    "description": "Vector<T>"
  },
  "lm": {
    "prefix": "lm",
    "body": [
      "let mut ${1:x} = ${2:target};"
    ],
    "description": "let mut"
  },
  "heap": {
    "prefix": "heap",
    "body": [
      "let mut ${1:q} = BinaryHeap::<${2:_}>::new();"
    ],
    "description": "BinaryHeap"
  },
  "bset": {
    "prefix": "bset",
    "body": [
      "let mut ${1:set} = BTreeSet::<${2:_}>::new();"
    ],
    "description": "BTreeSet"
  },
  "hset": {
    "prefix": "hset",
    "body": [
      "let mut ${1:set} = HashSet::<${2:_}>::new();"
    ],
    "description": "HashSet"
  },
  "bmap": {
    "prefix": "bmap",
    "body": [
      "let mut ${1:map} = BTreeMap::<${2:_}, ${3:_}>::new();"
    ],
    "description": "BTreeMap"
  },
  "hmap": {
    "prefix": "hmap",
    "body": [
      "let mut ${1:map} = HashMap::<${2:_}, ${3:_}>::new();"
    ],
    "description": "HashMap"
  },
  "entry": {
    "prefix": ".entry",
    "body": [
      ".entry(${1:&x}).or_insert(${2:default})"
    ],
    "description": "entry api"
  },
  "que": {
    "prefix": "que",
    "body": [
      "let mut ${1:q} = VecDeque::<${2:_}>::new();"
    ],
    "description": "VecDeque"
  },
  "in": {
    "prefix": "in",
    "body": [
      "input! {",
      "    ${1:el}: ${2:type}",
      "}"
    ],
    "description": "input! macro"
  },
  "p": {
    "prefix": "p",
    "body": [
      "print!(\"${1:{}}\", ${2:x});"
    ],
    "description": "print! 1 expr"
  },
  "pl": {
    "prefix": "pl",
    "body": [
      "println!(\"{}\", ${1:x});"
    ],
    "description": "println! 1 expr"
  },
  "ps": {
    "prefix": "ps",
    "body": [
      "println!(\"${1:str}\");"
    ],
    "description": "println! string"
  },
  "w": {
    "prefix": "w",
    "body": [
      "write!(out, \"{}\", ${1:x}).unwrap();"
    ],
    "description": "write"
  },
  "wl": {
    "prefix": "wl",
    "body": [
      "writeln!(out, \"{}\", ${1:x}).unwrap();"
    ],
    "description": "writeln"
  },
  "ws": {
    "prefix": "ws",
    "body": [
      "writeln!(out, \"${1:str}\").unwrap();"
    ],
    "description": "writeln! string"
  },
  "fi": {
    "prefix": "fi",
    "body": [
      "for &${1:e} in ${2:v}.iter() {",
      "    ",
      "},"
    ],
    "description": "input! macro"
  },
  "fe": {
    "prefix": "fe",
    "body": [
      "for (i, &${1:e}) in ${2:v}.iter().enumerate() {",
      "    ",
      "}"
    ],
    "description": "input! macro"
  },
  "df": {
    "prefix": "df",
    "body": [
      "fn dfs(v: usize, p: usize, to: &Vec<Vec<usize>>) {",
      "    for &u in to[v].iter() {",
      "        if u == p {",
      "            continue;",
      "        }",
      "        dfs(u, v, to);",
      "    }",
      "}"
    ],
    "description": "dfs base"
  },
  "ti": {
    "prefix": "ti",
    "body": [
      "use std::time::Instant;",
      "macro_rules! measure {",
      "    ( $x:expr) => {{",
      "        let start = Instant::now();",
      "        let result = $x;",
      "        let end = start.elapsed();",
      "        println!(",
      "            \"[{0}:{1}] {2}\\n>> elapsed: {3:.6} sec\",",
      "            file!(),",
      "            line!(),",
      "            stringify!($x),",
      "            end.as_secs_f64(),",
      "        );",
      "        result",
      "    }};",
      "}${0:Target}"
    ],
    "description": "measure time macro"
  },
  "bi": {
    "prefix": "bi",
    "body": [
      "fn binary_search<R, F: Fn(${1:i64}) -> bool>(range: R, condition: F) -> $1",
      "where",
      "    R: std::ops::RangeBounds<$1>,",
      "{",
      "    let mut low = match range.start_bound() {",
      "        std::ops::Bound::Included(&a) => a,",
      "        _ => unreachable!(),",
      "    };",
      "    let mut high = match range.end_bound() {",
      "        std::ops::Bound::Excluded(&a) => a,",
      "        std::ops::Bound::Included(&a) => a + 1,",
      "        _ => unreachable!(),",
      "    };",
      "    assert!(condition(low));",
      "    while high - low > 1 {",
      "        let mid = (low + high) / 2;",
      "        if condition(mid) {",
      "            low = mid;",
      "        } else {",
      "            high = mid;",
      "        }",
      "    }",
      "    return low;",
      "}"
    ],
    "description": "binary search function"
  },
  "Argument": {
    "prefix": "Argument",
    "body": [
      "#[derive(Debug, Copy, Clone, PartialEq, Eq)]",
      "pub struct Argument {",
      "    a: i64,",
      "    b: i64,",
      "}",
      "impl Argument {",
      "    pub fn new(a: i64, b: i64) -> Self {",
      "        Argument { a, b }",
      "    }",
      "}",
      "impl PartialOrd for Argument {",
      "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {",
      "        (self.a * other.b).partial_cmp(&(other.a * self.b))",
      "    }",
      "}"
    ]
  },
  "BIT": {
    "prefix": "BIT",
    "body": [
      "pub struct FenwickTree<T> {",
      "    n: usize,",
      "    tree: Vec<T>,",
      "    e: T,",
      "}",
      "#[allow(dead_code)]",
      "impl<T: std::ops::AddAssign + Clone> FenwickTree<T> {",
      "    pub fn new(n: usize, e: T) -> Self {",
      "        FenwickTree {",
      "            n,",
      "            tree: vec![e.clone(); n],",
      "            e,",
      "        }",
      "    }",
      "    /// A[i] += w",
      "    pub fn add(&mut self, mut idx: usize, w: T) {",
      "        idx += 1;",
      "        while idx <= self.n {",
      "            self.tree[idx - 1] += w.clone();",
      "            idx += idx & idx.wrapping_neg();",
      "        }",
      "    }",
      "    /// return A[0] + ... + A[idx-1]",
      "    pub fn accum(&self, mut idx: usize) -> T {",
      "        let mut sum = self.e.clone();",
      "        while idx > 0 {",
      "            sum += self.tree[idx - 1].clone();",
      "            idx &= idx - 1;",
      "        }",
      "        sum",
      "    }",
      "    /// return ∑ d[i] for i in R",
      "    pub fn sum<R>(&self, interval: R) -> T",
      "    where",
      "        T: std::ops::Sub<Output = T>,",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        let r = match interval.end_bound() {",
      "            std::ops::Bound::Excluded(&a) => a,",
      "            std::ops::Bound::Included(&a) => a + 1,",
      "            _ => self.n,",
      "        };",
      "        match interval.start_bound() {",
      "            std::ops::Bound::Included(&l) => self.accum(r) - self.accum(l),",
      "            _ => self.accum(r),",
      "        }",
      "    }",
      "}"
    ]
  },
  "BinarySearch": {
    "prefix": "BinarySearch",
    "body": [
      "pub trait BinarySearch<T> {",
      "    fn lower_bound(&self, x: &T) -> Option<usize>;",
      "    fn upper_bound(&self, x: &T) -> Option<usize>;",
      "}",
      "#[allow(dead_code)]",
      "impl<T: Ord> BinarySearch<T> for [T] {",
      "    /// Returns an index to the first element in `[T]` which does not compare less than `x`.",
      "    fn lower_bound(&self, x: &T) -> Option<usize> {",
      "        let mut low = 0;",
      "        let mut high = self.len();",
      "        if self[high - 1] < *x {",
      "            return None;",
      "        }",
      "        while low != high {",
      "            let mid = (low + high) / 2;",
      "            match self[mid].cmp(x) {",
      "                std::cmp::Ordering::Less => {",
      "                    low = mid + 1;",
      "                }",
      "                std::cmp::Ordering::Equal | std::cmp::Ordering::Greater => {",
      "                    high = mid;",
      "                }",
      "            }",
      "        }",
      "        Some(low)",
      "    }",
      "    /// Returns an index to the first element in `[T]` which compares greater than `x`.",
      "    fn upper_bound(&self, x: &T) -> Option<usize> {",
      "        let mut low = 0;",
      "        let mut high = self.len();",
      "        if self[high - 1] <= *x {",
      "            return None;",
      "        }",
      "        while low != high {",
      "            let mid = (low + high) / 2;",
      "            match self[mid].cmp(x) {",
      "                std::cmp::Ordering::Less | std::cmp::Ordering::Equal => {",
      "                    low = mid + 1;",
      "                }",
      "                std::cmp::Ordering::Greater => {",
      "                    high = mid;",
      "                }",
      "            }",
      "        }",
      "        Some(low)",
      "    }",
      "}"
    ]
  },
  "BitSet": {
    "prefix": "BitSet",
    "body": [
      "const TRUE: &bool = &true;",
      "const FALSE: &bool = &false;",
      "#[derive(Clone, Debug)]",
      "/// Efficient bool collection",
      "pub struct BitSet {",
      "    buf: Vec<u64>,",
      "    size: usize,",
      "}",
      "impl BitSet {",
      "    #[allow(dead_code)]",
      "    pub fn new(size: usize) -> BitSet {",
      "        BitSet {",
      "            buf: vec![0; (size + 63) / 64],",
      "            size,",
      "        }",
      "    }",
      "    #[allow(dead_code)]",
      "    pub fn set(&mut self, i: usize, b: bool) {",
      "        assert!(i < self.size);",
      "        if b {",
      "            self.buf[i >> 6] |= 1 << (i & 63);",
      "        } else {",
      "            self.buf[i >> 6] &= !(1 << (i & 63));",
      "        }",
      "    }",
      "    pub fn count_ones(&self) -> u32 {",
      "        self.buf.iter().map(|x| x.count_ones()).sum()",
      "    }",
      "    pub fn chomp(&mut self) {",
      "        let r = self.size & 63;",
      "        if r != 0 {",
      "            if let Some(x) = self.buf.last_mut() {",
      "                let d = 64 - r;",
      "                *x = (*x << d) >> d;",
      "            }",
      "        }",
      "    }",
      "}",
      "impl std::ops::Index<usize> for BitSet {",
      "    type Output = bool;",
      "    fn index(&self, index: usize) -> &bool {",
      "        [FALSE, TRUE][(self.buf[index >> 6] >> (index & 63)) as usize & 1]",
      "    }",
      "}",
      "#[allow(clippy::suspicious_op_assign_impl)]",
      "impl std::ops::ShlAssign<usize> for BitSet {",
      "    fn shl_assign(&mut self, x: usize) {",
      "        let q = x >> 6;",
      "        let r = x & 63;",
      "        if q >= self.buf.len() {",
      "            for x in &mut self.buf {",
      "                *x = 0;",
      "            }",
      "            return;",
      "        }",
      "        if r == 0 {",
      "            for i in (q..self.buf.len()).rev() {",
      "                self.buf[i] = self.buf[i - q];",
      "            }",
      "        } else {",
      "            for i in (q + 1..self.buf.len()).rev() {",
      "                self.buf[i] = (self.buf[i - q] << r) | (self.buf[i - q - 1] >> (64 - r));",
      "            }",
      "            self.buf[q] = self.buf[0] << r;",
      "        }",
      "        for x in &mut self.buf[..q] {",
      "            *x = 0;",
      "        }",
      "        self.chomp();",
      "    }",
      "}",
      "impl std::ops::Shl<usize> for BitSet {",
      "    type Output = Self;",
      "    fn shl(mut self, x: usize) -> Self {",
      "        self <<= x;",
      "        self",
      "    }",
      "}",
      "#[allow(clippy::suspicious_op_assign_impl)]",
      "impl std::ops::ShrAssign<usize> for BitSet {",
      "    fn shr_assign(&mut self, x: usize) {",
      "        let q = x >> 6;",
      "        let r = x & 63;",
      "        if q >= self.buf.len() {",
      "            for x in &mut self.buf {",
      "                *x = 0;",
      "            }",
      "            return;",
      "        }",
      "        if r == 0 {",
      "            for i in 0..self.buf.len() - q {",
      "                self.buf[i] = self.buf[i + q];",
      "            }",
      "        } else {",
      "            for i in 0..self.buf.len() - q - 1 {",
      "                self.buf[i] = (self.buf[i + q] >> r) | (self.buf[i + q + 1] << (64 - r));",
      "            }",
      "            let len = self.buf.len();",
      "            self.buf[len - q - 1] = self.buf[len - 1] >> r;",
      "        }",
      "        let len = self.buf.len();",
      "        for x in &mut self.buf[len - q..] {",
      "            *x = 0;",
      "        }",
      "    }",
      "}",
      "impl std::ops::Shr<usize> for BitSet {",
      "    type Output = Self;",
      "    fn shr(mut self, x: usize) -> Self {",
      "        self >>= x;",
      "        self",
      "    }",
      "}",
      "impl<'a> std::ops::BitAndAssign<&'a BitSet> for BitSet {",
      "    fn bitand_assign(&mut self, rhs: &'a Self) {",
      "        for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {",
      "            *a &= *b;",
      "        }",
      "    }",
      "}",
      "impl<'a> std::ops::BitAnd<&'a BitSet> for BitSet {",
      "    type Output = Self;",
      "    fn bitand(mut self, rhs: &'a Self) -> Self {",
      "        self &= rhs;",
      "        self",
      "    }",
      "}",
      "impl<'a> std::ops::BitOrAssign<&'a BitSet> for BitSet {",
      "    fn bitor_assign(&mut self, rhs: &'a Self) {",
      "        for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {",
      "            *a |= *b;",
      "        }",
      "        self.chomp();",
      "    }",
      "}",
      "impl<'a> std::ops::BitOr<&'a BitSet> for BitSet {",
      "    type Output = Self;",
      "    fn bitor(mut self, rhs: &'a Self) -> Self {",
      "        self |= rhs;",
      "        self",
      "    }",
      "}",
      "impl<'a> std::ops::BitXorAssign<&'a BitSet> for BitSet {",
      "    fn bitxor_assign(&mut self, rhs: &'a Self) {",
      "        for (a, b) in self.buf.iter_mut().zip(rhs.buf.iter()) {",
      "            *a ^= *b;",
      "        }",
      "        self.chomp();",
      "    }",
      "}",
      "impl<'a> std::ops::BitXor<&'a BitSet> for BitSet {",
      "    type Output = Self;",
      "    fn bitxor(mut self, rhs: &'a Self) -> Self {",
      "        self ^= rhs;",
      "        self",
      "    }",
      "}"
    ]
  },
  "CRT": {
    "prefix": "CRT",
    "body": [
      "use std::mem::swap;",
      "/// Return (g, x)",
      "/// Where",
      "///   g = gcd(a, b)",
      "///   a * x ≡ g (mod b)",
      "/// ⇔ g = a * x + b * y",
      "/// ⇔ y = (g - a * x) / b",
      "pub fn inv_gcd(a: i64, b: i64) -> (i64, i64) {",
      "    let a = a.rem_euclid(b);",
      "    if a == 0 {",
      "        return (b, 0);",
      "    }",
      "    let mut s = b;",
      "    let mut t = a;",
      "    let mut m0 = 0;",
      "    let mut m1 = 1;",
      "    while t != 0 {",
      "        let u = s / t;",
      "        s -= t * u;",
      "        m0 -= m1 * u;",
      "        swap(&mut s, &mut t);",
      "        swap(&mut m0, &mut m1);",
      "    }",
      "    if m0 < 0 {",
      "        m0 += b / s;",
      "    }",
      "    (s, m0)",
      "}",
      "/// Return (k, m)",
      "/// 連立合同式X ≡ ri (mod mi)の解",
      "/// X ≡ k (mod m)",
      "pub fn crt(r: &[i64], m: &[i64]) -> (i64, i64) {",
      "    assert_eq!(r.len(), m.len());",
      "    let (mut r0, mut m0) = (0, 1);",
      "    for (&(mut ri), &(mut mi)) in r.iter().zip(m.iter()) {",
      "        assert!(1 <= mi);",
      "        ri = ri.rem_euclid(mi);",
      "        if m0 < mi {",
      "            swap(&mut r0, &mut ri);",
      "            swap(&mut m0, &mut mi);",
      "        }",
      "        if m0 % mi == 0 {",
      "            if r0 % mi != ri {",
      "                return (0, 0);",
      "            }",
      "            continue;",
      "        }",
      "        let (g, im) = inv_gcd(m0, mi);",
      "        let ui = mi / g;",
      "        if (ri - r0) % g != 0 {",
      "            return (0, 0);",
      "        }",
      "        let x = (ri - r0) / g % ui * im % ui;",
      "        r0 += x * m0;",
      "        m0 *= ui;",
      "        if r0 < 0 {",
      "            r0 += m0",
      "        };",
      "    }",
      "    (r0, m0)",
      "}"
    ]
  },
  "Chmax": {
    "prefix": "Chmax",
    "body": [
      "#[allow(unused_macros)]",
      "macro_rules ! max {(\\$ a : expr \\$ (, ) * ) => {{\\$ a } } ; (\\$ a : expr , \\$ b : expr \\$ (, ) * ) => {{std :: cmp :: max (\\$ a , \\$ b ) } } ; (\\$ a : expr , \\$ (\\$ rest : expr ) ,+ \\$ (, ) * ) => {{std :: cmp :: max (\\$ a , max ! (\\$ (\\$ rest ) ,+ ) ) } } ; }",
      "#[allow(unused_macros)]",
      "macro_rules ! chmax {(\\$ base : expr , \\$ (\\$ cmps : expr ) ,+ \\$ (, ) * ) => {{let cmp_max = max ! (\\$ (\\$ cmps ) ,+ ) ; if \\$ base < cmp_max {\\$ base = cmp_max ; true } else {false } } } ; }"
    ]
  },
  "Chmin": {
    "prefix": "Chmin",
    "body": [
      "#[allow(unused_macros)]",
      "macro_rules ! min {(\\$ a : expr \\$ (, ) * ) => {{\\$ a } } ; (\\$ a : expr , \\$ b : expr \\$ (, ) * ) => {{std :: cmp :: min (\\$ a , \\$ b ) } } ; (\\$ a : expr , \\$ (\\$ rest : expr ) ,+ \\$ (, ) * ) => {{std :: cmp :: min (\\$ a , min ! (\\$ (\\$ rest ) ,+ ) ) } } ; }",
      "#[allow(unused_macros)]",
      "macro_rules ! chmin {(\\$ base : expr , \\$ (\\$ cmps : expr ) ,+ \\$ (, ) * ) => {{let cmp_min = min ! (\\$ (\\$ cmps ) ,+ ) ; if \\$ base > cmp_min {\\$ base = cmp_min ; true } else {false } } } ; }"
    ]
  },
  "Debug": {
    "prefix": "Debug",
    "body": [
      "#[allow(unused_macros)]",
      "macro_rules ! debug {(\\$ (\\$ e : expr ) ,* ) => {# [cfg (debug_assertions ) ] \\$ ({let (e , mut err ) = (stringify ! (\\$ e ) , std :: io :: stderr () ) ; writeln ! (err , \"{} = {:?}\" , e , \\$ e ) . unwrap () } ) * } ; }"
    ]
  },
  "EXT_GCD": {
    "prefix": "EXT_GCD",
    "body": [
      "/// Return (x, y)",
      "/// Where",
      "///   a * x + b * y = gcd(a, b)",
      "pub fn ext_gcd(a: i64, b: i64) -> (i64, i64) {",
      "    let (mut x, mut y) = __ext_gcd(a.abs(), b.abs());",
      "    if a.is_negative() {",
      "        x *= -1;",
      "    }",
      "    if b.is_negative() {",
      "        y *= -1;",
      "    }",
      "    (x, y)",
      "}",
      "fn __ext_gcd(a: i64, b: i64) -> (i64, i64) {",
      "    if a < 0 || b < 0 {",
      "        panic!();",
      "    }",
      "    match b {",
      "        0 => (1, 0),",
      "        _ => {",
      "            let (x, y) = __ext_gcd(b, a % b);",
      "            (y, x - (a / b) * y)",
      "        }",
      "    }",
      "}"
    ]
  },
  "Factorial": {
    "prefix": "Factorial",
    "body": [
      "pub struct Fact {",
      "    fact: Vec<Mint>,",
      "    ifact: Vec<Mint>,",
      "}",
      "impl Fact {",
      "    pub fn new(n: usize) -> Self {",
      "        let mut fact = vec![Mint::new(1); n + 1];",
      "        let mut ifact = vec![Mint::new(1); n + 1];",
      "        for i in 1..n + 1 {",
      "            fact[i] = fact[i - 1] * i as i64;",
      "        }",
      "        ifact[n] = fact[n].inv();",
      "        for i in (1..n + 1).rev() {",
      "            ifact[i - 1] = ifact[i] * i as i64;",
      "        }",
      "        Fact { fact, ifact }",
      "    }",
      "    pub fn c(&self, n: usize, r: usize) -> Mint {",
      "        if r > n {",
      "            Mint::new(0)",
      "        } else {",
      "            self.fact[n] * self.ifact[r] * self.ifact[n - r]",
      "        }",
      "    }",
      "    pub fn p(&self, n: usize, r: usize) -> Mint {",
      "        if r > n {",
      "            Mint::new(0)",
      "        } else {",
      "            self.fact[n] * self.ifact[n - r]",
      "        }",
      "    }",
      "}"
    ]
  },
  "GCD": {
    "prefix": "GCD",
    "body": [
      "pub fn gcd(a: i64, b: i64) -> i64 {",
      "    if b == 0 {",
      "        a.abs()",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}"
    ]
  },
  "Group": {
    "prefix": "Group",
    "body": [
      "pub trait Group {",
      "    fn id() -> Self;",
      "    fn f(a: Self, b: Self) -> Self;",
      "    fn g(a: Self, b: Self) -> Self;",
      "}"
    ]
  },
  "GroupIntAdd": {
    "prefix": "GroupIntAdd",
    "body": [
      "pub trait Group {",
      "    fn id() -> Self;",
      "    fn f(a: Self, b: Self) -> Self;",
      "    fn g(a: Self, b: Self) -> Self;",
      "}",
      "impl Group for i64 {",
      "    fn id() -> Self {",
      "        0",
      "    }",
      "    fn f(a: Self, b: Self) -> Self {",
      "        a + b",
      "    }",
      "    fn g(a: Self, b: Self) -> Self {",
      "        a - b",
      "    }",
      "}"
    ]
  },
  "INF": {
    "prefix": "INF",
    "body": [
      "#[allow(dead_code)]",
      "const INFI: i32 = 1001001001;",
      "#[allow(dead_code)]",
      "const INFL: i64 = 1001001001001001001;"
    ]
  },
  "INV_GCD": {
    "prefix": "INV_GCD",
    "body": [
      "use std::mem::swap;",
      "/// Return (g, x)",
      "/// Where",
      "///   g = gcd(a, b)",
      "///   a * x ≡ g (mod b)",
      "/// ⇔ g = a * x + b * y",
      "/// ⇔ y = (g - a * x) / b",
      "pub fn inv_gcd(a: i64, b: i64) -> (i64, i64) {",
      "    let a = a.rem_euclid(b);",
      "    if a == 0 {",
      "        return (b, 0);",
      "    }",
      "    let mut s = b;",
      "    let mut t = a;",
      "    let mut m0 = 0;",
      "    let mut m1 = 1;",
      "    while t != 0 {",
      "        let u = s / t;",
      "        s -= t * u;",
      "        m0 -= m1 * u;",
      "        swap(&mut s, &mut t);",
      "        swap(&mut m0, &mut m1);",
      "    }",
      "    if m0 < 0 {",
      "        m0 += b / s;",
      "    }",
      "    (s, m0)",
      "}"
    ]
  },
  "LCA": {
    "prefix": "LCA",
    "body": [
      "struct LCA {",
      "    n: usize,",
      "    k: usize,",
      "    edge: Vec<Vec<usize>>,",
      "    depth: Vec<usize>,",
      "    par: Vec<Vec<Option<usize>>>,",
      "}",
      "#[allow(dead_code)]",
      "impl LCA {",
      "    fn new(n: usize) -> Self {",
      "        LCA {",
      "            n,",
      "            k: 1,",
      "            edge: vec![vec![]; n],",
      "            depth: vec![0; n],",
      "            par: vec![vec![None; n]],",
      "        }",
      "    }",
      "    fn add_edge(&mut self, u: usize, v: usize) {",
      "        self.edge[u].push(v);",
      "        self.edge[v].push(u);",
      "    }",
      "    fn from_edges(uv: &[(usize, usize)]) -> Self {",
      "        let n = uv.len() + 1;",
      "        let mut edge = vec![vec![]; n];",
      "        for &(u, v) in uv {",
      "            edge[u].push(v);",
      "            edge[v].push(u);",
      "        }",
      "        let mut lca = LCA {",
      "            n,",
      "            k: 1,",
      "            edge,",
      "            depth: vec![0; n],",
      "            par: vec![vec![None; n]],",
      "        };",
      "        lca.init();",
      "        lca",
      "    }",
      "    fn init(&mut self) {",
      "        self.dfs(0, 0, 0);",
      "        let mut flag = false;",
      "        for k in 0.. {",
      "            self.par.push(vec![None; self.n]);",
      "            for v in 0..self.n {",
      "                if let Some(p1) = self.par[k][v] {",
      "                    if let Some(p2) = self.par[k][p1] {",
      "                        self.par[k + 1][v] = Some(p2);",
      "                        flag = true;",
      "                    }",
      "                }",
      "            }",
      "            if !flag {",
      "                self.par.pop();",
      "                break;",
      "            }",
      "            self.k += 1;",
      "            flag = false;",
      "        }",
      "    }",
      "    fn dfs(&mut self, u: usize, p: usize, d: usize) {",
      "        self.depth[u] = d;",
      "        for v in self.edge[u].clone() {",
      "            if v == p {",
      "                continue;",
      "            }",
      "            self.par[0][v] = Some(u);",
      "            self.dfs(v, u, d + 1);",
      "        }",
      "    }",
      "    /// return (LCA of u and v)",
      "    fn lca(&self, mut u: usize, mut v: usize) -> usize {",
      "        if self.depth[u] < self.depth[v] {",
      "            std::mem::swap(&mut u, &mut v);",
      "        }",
      "        for k in 0.. {",
      "            if (self.depth[u] - self.depth[v]) >> k & 1 == 1 {",
      "                u = self.par[k][u].unwrap();",
      "            }",
      "            if self.depth[u] == self.depth[v] {",
      "                break;",
      "            }",
      "        }",
      "        if u == v {",
      "            return u;",
      "        }",
      "        for k in (0..self.k).rev() {",
      "            if self.par[k][u] != self.par[k][v] {",
      "                u = self.par[k][u].unwrap();",
      "                v = self.par[k][v].unwrap();",
      "            }",
      "        }",
      "        self.par[0][u].unwrap()",
      "    }",
      "    /// return (dist between u-v)",
      "    fn dist(&self, u: usize, v: usize) -> usize {",
      "        let p = self.lca(u, v);",
      "        self.depth[u] + self.depth[v] - 2 * self.depth[p]",
      "    }",
      "    /// return (a is on path u-v)",
      "    fn is_on_path(&self, u: usize, v: usize, a: usize) -> bool {",
      "        self.dist(u, v) == self.dist(u, a) + self.dist(a, v)",
      "    }",
      "}"
    ]
  },
  "LCP": {
    "prefix": "LCP",
    "body": [
      "pub struct SaffixArray {",
      "    n: usize,",
      "    s: String,",
      "    sa: Vec<usize>,",
      "}",
      "pub fn compare_sa(rank: &[i64], n: usize, k: usize, i: usize, j: usize) -> std::cmp::Ordering {",
      "    if rank[i] != rank[j] {",
      "        rank[i].cmp(&rank[j])",
      "    } else {",
      "        let ri = if i + k <= n { rank[i + k] } else { -1 };",
      "        let rj = if j + k <= n { rank[j + k] } else { -1 };",
      "        ri.cmp(&rj)",
      "    }",
      "}",
      "impl SaffixArray {",
      "    pub fn construct(s: &str) -> Self {",
      "        let n = s.len();",
      "        let mut sa = (0..=n).collect::<Vec<usize>>();",
      "        let mut rank = s.as_bytes().iter().map(|&c| c as i64).collect::<Vec<i64>>();",
      "        rank.push(-1);",
      "        let mut k = 1;",
      "        let mut tmp = vec![0; n + 1];",
      "        while k <= n {",
      "            sa.sort_by(|a, b| compare_sa(&rank, n, k, *a, *b));",
      "            tmp[sa[0]] = 0;",
      "            for i in 1..=n {",
      "                tmp[sa[i]] = tmp[sa[i - 1]]",
      "                    + match compare_sa(&rank, n, k, sa[i - 1], sa[i]) {",
      "                        std::cmp::Ordering::Less => 1,",
      "                        _ => 0,",
      "                    };",
      "            }",
      "            rank[..=n].copy_from_slice(&tmp[..=n]);",
      "            k <<= 1;",
      "        }",
      "        SaffixArray {",
      "            n: s.len(),",
      "            s: s.to_string(),",
      "            sa,",
      "        }",
      "    }",
      "    pub fn contain(&self, t: &str) -> bool {",
      "        let mut low = 0;",
      "        let mut high = self.n;",
      "        let m = t.len();",
      "        while high - low > 1 {",
      "            let mid = (high + low) / 2;",
      "            if self.s[self.sa[mid]..self.sa[mid] + m] <= *t {",
      "                low = mid;",
      "            } else {",
      "                high = mid;",
      "            }",
      "        }",
      "        self.s[self.sa[low]..self.sa[low] + m] == *t",
      "    }",
      "}",
      "pub fn lcp_array(s: &str) -> Vec<usize> {",
      "    let n = s.len();",
      "    let sa = SaffixArray::construct(s).sa;",
      "    let mut rank = vec![0; n + 1];",
      "    for i in 0..=n {",
      "        rank[sa[i]] = i;",
      "    }",
      "    let mut lcp = vec![0; n + 1];",
      "    let mut h = 0usize;",
      "    for i in 1..n {",
      "        let j = sa[rank[i] - 1];",
      "        h = h.saturating_sub(1);",
      "        while i + h <= n && j + h <= n {",
      "            if sa[i + h] != sa[j + h] {",
      "                break;",
      "            }",
      "            h += 1;",
      "        }",
      "        lcp[rank[i] - 1] = h;",
      "    }",
      "    lcp",
      "}"
    ]
  },
  "LasySegmentTree": {
    "prefix": "LasySegmentTree",
    "body": [
      "pub struct Node;",
      "impl ME for Node {",
      "    type M = i64;",
      "    type E = i64;",
      "    fn id_m() -> Self::M {",
      "        0",
      "    }",
      "    fn id_e() -> Self::E {",
      "        0",
      "    }",
      "    fn f(a: &Self::M, b: &Self::M) -> Self::M {",
      "        a + b",
      "    }",
      "    fn g(_a: &Self::M, b: &Self::E) -> Self::M {",
      "        *b",
      "    }",
      "    fn h(_a: &Self::E, b: &Self::E) -> Self::E {",
      "        *b",
      "    }",
      "    fn p(a: &Self::E, k: usize) -> Self::E {",
      "        a * k as i64",
      "    }",
      "}",
      "pub trait ME {",
      "    type M: Clone;",
      "    type E: Clone + PartialEq;",
      "    fn id_m() -> Self::M;",
      "    fn id_e() -> Self::E;",
      "    fn id() -> (Self::M, Self::E) {",
      "        (Self::id_m(), Self::id_e())",
      "    }",
      "    fn f(a: &Self::M, b: &Self::M) -> Self::M;",
      "    fn g(a: &Self::M, b: &Self::E) -> Self::M;",
      "    fn h(a: &Self::E, b: &Self::E) -> Self::E;",
      "    fn p(a: &Self::E, k: usize) -> Self::E;",
      "}",
      "pub struct LazySegmentTree<T: ME> {",
      "    n: usize,",
      "    width: usize,",
      "    dat: Vec<(T::M, T::E)>,",
      "}",
      "#[allow(dead_code)]",
      "impl<T: ME> LazySegmentTree<T> {",
      "    fn new(n: usize) -> Self {",
      "        let width = n.next_power_of_two();",
      "        Self {",
      "            n,",
      "            width,",
      "            dat: vec![T::id(); (width << 1) - 1],",
      "        }",
      "    }",
      "    fn from_vec(a: &[T::M]) -> Self {",
      "        let n = a.len();",
      "        let width = n.next_power_of_two();",
      "        let mut dat = vec![T::id(); (width << 1) - 1];",
      "        for i in 0..n {",
      "            dat[i + width - 1].0 = a[i].clone();",
      "        }",
      "        for i in (0..width - 1).rev() {",
      "            dat[i].0 = T::f(&dat[(i << 1) + 1].0, &dat[(i << 1) + 2].0);",
      "        }",
      "        Self { n, width, dat }",
      "    }",
      "    fn __eval(&mut self, now: usize, k: usize) {",
      "        let e = T::p(&self.dat[now].1, k);",
      "        self.dat[now].0 = T::g(&self.dat[now].0, &e);",
      "        if k > 1 {",
      "            self.dat[(now << 1) + 1].1 = T::h(&self.dat[(now << 1) + 1].1, &self.dat[now].1);",
      "            self.dat[(now << 1) + 2].1 = T::h(&self.dat[(now << 1) + 2].1, &self.dat[now].1);",
      "        }",
      "        self.dat[now].1 = T::id_e();",
      "    }",
      "    fn __update(&mut self, x: &T::E, now: usize, lc: usize, rc: usize, l: usize, r: usize) {",
      "        self.__eval(now, rc - lc);",
      "        if l <= lc && rc <= r {",
      "            self.dat[now].1 = T::h(&self.dat[now].1, x);",
      "            self.__eval(now, rc - lc);",
      "        } else if l < rc && lc < r {",
      "            self.__update(x, (now << 1) + 1, lc, (lc + rc) / 2, l, r);",
      "            self.__update(x, (now << 1) + 2, (lc + rc) / 2, rc, l, r);",
      "            self.dat[now].0 = T::f(&self.dat[(now << 1) + 1].0, &self.dat[(now << 1) + 2].0);",
      "        }",
      "    }",
      "    fn update<R>(&mut self, range: R, x: &T::E)",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        let l = match range.start_bound() {",
      "            std::ops::Bound::Included(&a) => a,",
      "            _ => 0,",
      "        };",
      "        let r = match range.end_bound() {",
      "            std::ops::Bound::Excluded(&a) => a,",
      "            std::ops::Bound::Included(&a) => a + 1,",
      "            _ => self.n,",
      "        };",
      "        self.__update(x, 0, 0, self.width, l, r);",
      "    }",
      "    fn __prod(&mut self, now: usize, lc: usize, rc: usize, l: usize, r: usize) -> T::M {",
      "        self.__eval(now, rc - lc);",
      "        if rc <= l || r <= lc {",
      "            T::id_m()",
      "        } else if l <= lc && rc <= r {",
      "            self.dat[now].0.clone()",
      "        } else {",
      "            T::f(",
      "                &self.__prod((now << 1) + 1, lc, (lc + rc) >> 1, l, r),",
      "                &self.__prod((now << 1) + 2, (lc + rc) >> 1, rc, l, r),",
      "            )",
      "        }",
      "    }",
      "    fn prod<R>(&mut self, range: R) -> T::M",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        let l = match range.start_bound() {",
      "            std::ops::Bound::Included(&a) => a,",
      "            _ => 0,",
      "        };",
      "        let r = match range.end_bound() {",
      "            std::ops::Bound::Excluded(&a) => a,",
      "            std::ops::Bound::Included(&a) => a + 1,",
      "            _ => self.width,",
      "        };",
      "        self.__prod(0, 0, self.width, l, r)",
      "    }",
      "}"
    ]
  },
  "Max": {
    "prefix": "Max",
    "body": [
      "#[allow(unused_macros)]",
      "macro_rules ! max {(\\$ a : expr \\$ (, ) * ) => {{\\$ a } } ; (\\$ a : expr , \\$ b : expr \\$ (, ) * ) => {{std :: cmp :: max (\\$ a , \\$ b ) } } ; (\\$ a : expr , \\$ (\\$ rest : expr ) ,+ \\$ (, ) * ) => {{std :: cmp :: max (\\$ a , max ! (\\$ (\\$ rest ) ,+ ) ) } } ; }"
    ]
  },
  "MaxFloat": {
    "prefix": "MaxFloat",
    "body": [
      "pub trait Monoid {",
      "    fn id() -> Self;",
      "    fn f(a: Self, b: Self) -> Self;",
      "}",
      "#[derive(Debug, Copy, Clone, PartialEq)]",
      "pub enum MaxFloat {",
      "    Minimal,",
      "    Val(f64),",
      "}",
      "impl Eq for MaxFloat {}",
      "impl MaxFloat {",
      "    pub fn unwrap(self) -> f64 {",
      "        if let Self::Val(x) = self {",
      "            x",
      "        } else {",
      "            panic!();",
      "        }",
      "    }",
      "    pub fn map<F>(self, f: F) -> Self",
      "    where",
      "        F: Fn(f64) -> f64,",
      "    {",
      "        if let Self::Val(x) = self {",
      "            Self::Val(f(x))",
      "        } else {",
      "            Self::Minimal",
      "        }",
      "    }",
      "}",
      "impl std::cmp::PartialOrd for MaxFloat {",
      "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {",
      "        match (self, other) {",
      "            (&Self::Val(x), &Self::Val(y)) => x.partial_cmp(&y),",
      "            (&Self::Val(_), &Self::Minimal) => Some(Ordering::Greater),",
      "            (&Self::Minimal, &Self::Val(_)) => Some(Ordering::Less),",
      "            _ => Some(Ordering::Equal),",
      "        }",
      "    }",
      "}",
      "impl std::cmp::Ord for MaxFloat {",
      "    fn cmp(&self, other: &Self) -> Ordering {",
      "        self.partial_cmp(other).unwrap()",
      "    }",
      "}",
      "impl std::ops::MulAssign<MaxFloat> for MaxFloat {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        if *self < rhs {",
      "            *self = rhs;",
      "        }",
      "    }",
      "}",
      "impl std::ops::Mul for MaxFloat {",
      "    type Output = Self;",
      "    fn mul(self, other: Self) -> Self {",
      "        if self > other {",
      "            self",
      "        } else {",
      "            other",
      "        }",
      "    }",
      "}",
      "impl Monoid for MaxFloat {",
      "    fn id() -> Self {",
      "        MaxFloat::Minimal",
      "    }",
      "    fn f(a: Self, b: Self) -> Self {",
      "        a * b",
      "    }",
      "}"
    ]
  },
  "MaxInt": {
    "prefix": "MaxInt",
    "body": [
      "pub trait Monoid {",
      "    fn id() -> Self;",
      "    fn f(a: Self, b: Self) -> Self;",
      "}",
      "#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]",
      "pub enum MaxInt {",
      "    Minimal,",
      "    Val(i64),",
      "}",
      "impl std::ops::Mul for MaxInt {",
      "    type Output = Self;",
      "    fn mul(self, other: Self) -> Self {",
      "        if self > other {",
      "            self",
      "        } else {",
      "            other",
      "        }",
      "    }",
      "}",
      "#[allow(dead_code)]",
      "impl MaxInt {",
      "    fn unwrap(self) -> i64 {",
      "        if let Self::Val(x) = self {",
      "            x",
      "        } else {",
      "            panic!();",
      "        }",
      "    }",
      "    fn map<F>(self, f: F) -> Self",
      "    where",
      "        F: Fn(i64) -> i64,",
      "    {",
      "        if let Self::Val(x) = self {",
      "            Self::Val(f(x))",
      "        } else {",
      "            Self::Minimal",
      "        }",
      "    }",
      "    fn map2<F>(self, b: Self, f: F) -> Self",
      "    where",
      "        F: Fn(i64, i64) -> i64,",
      "    {",
      "        match (self, b) {",
      "            (Self::Val(x), Self::Val(y)) => Self::Val(f(x, y)),",
      "            _ => Self::Minimal,",
      "        }",
      "    }",
      "    fn get_or(self, default: i64) -> i64 {",
      "        if let Self::Val(x) = self {",
      "            x",
      "        } else {",
      "            default",
      "        }",
      "    }",
      "}",
      "impl Monoid for MaxInt {",
      "    fn id() -> Self {",
      "        MaxInt::Minimal",
      "    }",
      "    fn f(a: Self, b: Self) -> Self {",
      "        a * b",
      "    }",
      "}"
    ]
  },
  "Min": {
    "prefix": "Min",
    "body": [
      "#[allow(unused_macros)]",
      "macro_rules ! min {(\\$ a : expr \\$ (, ) * ) => {{\\$ a } } ; (\\$ a : expr , \\$ b : expr \\$ (, ) * ) => {{std :: cmp :: min (\\$ a , \\$ b ) } } ; (\\$ a : expr , \\$ (\\$ rest : expr ) ,+ \\$ (, ) * ) => {{std :: cmp :: min (\\$ a , min ! (\\$ (\\$ rest ) ,+ ) ) } } ; }"
    ]
  },
  "MinCostFlow": {
    "prefix": "MinCostFlow",
    "body": [
      "pub struct MCFGraph {",
      "    n: usize,",
      "    pos: Vec<(usize, usize)>,",
      "    g: Vec<Vec<_Edge>>,",
      "    h: Vec<i64>,",
      "    cost_sum: i64,",
      "}",
      "pub struct Edge {",
      "    from: usize,",
      "    to: usize,",
      "    cap: i64,",
      "    flow: i64,",
      "    cost: i64,",
      "}",
      "pub struct _Edge {",
      "    to: usize,",
      "    rev: usize,",
      "    cap: i64,",
      "    cost: i64,",
      "}",
      "impl MCFGraph {",
      "    pub fn new(n: usize) -> Self {",
      "        MCFGraph {",
      "            n,",
      "            pos: Vec::new(),",
      "            g: std::iter::repeat_with(Vec::new).take(n).collect(),",
      "            h: vec![0; n],",
      "            cost_sum: 0,",
      "        }",
      "    }",
      "    pub fn add_edge(&mut self, from: usize, to: usize, cap: i64, cost: i64) {",
      "        self.pos.push((from, self.g[from].len()));",
      "        self.cost_sum += cost;",
      "        let r1 = self.g[to].len() + if to == from { 1 } else { 0 };",
      "        let r2 = self.g[from].len();",
      "        self.g[from].push(_Edge {",
      "            to,",
      "            rev: r1,",
      "            cap,",
      "            cost,",
      "        });",
      "        self.g[to].push(_Edge {",
      "            to: from,",
      "            rev: r2,",
      "            cap: 0,",
      "            cost: -cost,",
      "        });",
      "    }",
      "    pub fn get_edge(&self, idx: usize) -> Edge {",
      "        assert!(idx < self.pos.len());",
      "        let (from, i) = self.pos[idx];",
      "        let e = &self.g[from][i];",
      "        let re = &self.g[e.to][e.rev];",
      "        Edge {",
      "            from,",
      "            to: e.to,",
      "            cap: e.cap + re.cap,",
      "            flow: re.cap,",
      "            cost: e.cost,",
      "        }",
      "    }",
      "    pub fn edges(&self) -> Vec<Edge> {",
      "        (0..self.pos.len()).map(|i| self.get_edge(i)).collect()",
      "    }",
      "    pub fn cost(&mut self, s: usize, t: usize, mut flow: i64) -> Option<i64> {",
      "        let n = self.n;",
      "        let inf = std::i64::MAX;",
      "        let mut result = 0;",
      "        let mut q = BinaryHeap::<(Reverse<i64>, usize)>::new();",
      "        self.h = vec![0; n];",
      "        while flow > 0 {",
      "            let mut dist = vec![inf; n];",
      "            let mut prev = vec![(0, 0); n];",
      "            q.clear();",
      "            q.push((Reverse(0), s));",
      "            dist[s] = 0;",
      "            while let Some((Reverse(d), v)) = q.pop() {",
      "                if d > dist[v] {",
      "                    continue;",
      "                }",
      "                for (i, e) in self.g[v].iter().enumerate() {",
      "                    if e.cap > 0 && dist[e.to] > dist[v] + e.cost + self.h[v] - self.h[e.to] {",
      "                        dist[e.to] = dist[v] + e.cost + self.h[v] - self.h[e.to];",
      "                        prev[e.to] = (v, i);",
      "                        q.push((Reverse(dist[e.to]), e.to));",
      "                    }",
      "                }",
      "            }",
      "            if dist[t] == inf {",
      "                return None;",
      "            }",
      "            (0..n).for_each(|i| self.h[i] += dist[i]);",
      "            let mut f = flow;",
      "            let mut v = t;",
      "            while v != s {",
      "                let (u, i) = prev[v];",
      "                f = min(f, self.g[u][i].cap);",
      "                v = u;",
      "            }",
      "            flow -= f;",
      "            result += f * self.h[t];",
      "            let mut v = t;",
      "            while v != s {",
      "                let (u, i) = prev[v];",
      "                let rev = self.g[u][i].rev;",
      "                self.g[u][i].cap -= f;",
      "                self.g[v][rev].cap += f;",
      "                v = u;",
      "            }",
      "        }",
      "        Some(result)",
      "    }",
      "}"
    ]
  },
  "MinCut": {
    "prefix": "MinCut",
    "body": [
      "struct MFGraph {",
      "    _n: usize,",
      "    pos: Vec<(usize, usize)>,",
      "    g: Vec<Vec<_Edge>>,",
      "}",
      "#[allow(dead_code)]",
      "struct Edge {",
      "    from: usize,",
      "    to: usize,",
      "    cap: i64,",
      "    flow: i64,",
      "}",
      "#[derive(Clone)]",
      "struct _Edge {",
      "    to: usize,",
      "    cap: i64,",
      "    rev: usize,",
      "}",
      "#[allow(dead_code)]",
      "impl MFGraph {",
      "    fn new(n: usize) -> Self {",
      "        MFGraph {",
      "            _n: n,",
      "            pos: Vec::new(),",
      "            g: std::iter::repeat_with(Vec::new).take(n).collect(),",
      "        }",
      "    }",
      "    fn add_edge(&mut self, from: usize, to: usize, cap: i64) -> usize {",
      "        assert!(from < self._n);",
      "        assert!(to < self._n);",
      "        assert!(0 <= cap);",
      "        self.pos.push((from, self.g[from].len()));",
      "        let r1 = self.g[to].len() + if from == to { 1 } else { 0 };",
      "        let r2 = self.g[from].len();",
      "        self.g[from].push(_Edge { to, cap, rev: r1 });",
      "        self.g[to].push(_Edge {",
      "            to: from,",
      "            cap: 0,",
      "            rev: r2,",
      "        });",
      "        self.pos.len() - 1",
      "    }",
      "    fn get_edge(&self, idx: usize) -> Edge {",
      "        assert!(idx < self.pos.len());",
      "        let (from, i) = self.pos[idx];",
      "        let &_Edge { to, cap, rev } = &self.g[from][i];",
      "        let rev = &self.g[to][rev];",
      "        Edge {",
      "            from,",
      "            to,",
      "            cap: cap + rev.cap,",
      "            flow: rev.cap,",
      "        }",
      "    }",
      "    fn edges(&self) -> Vec<Edge> {",
      "        (0..self.pos.len()).map(|i| self.get_edge(i)).collect()",
      "    }",
      "    fn change_edge(&mut self, i: usize, new_cap: i64, new_flow: i64) {",
      "        assert!(i < self.pos.len());",
      "        assert!(0 <= new_flow && new_flow <= new_cap);",
      "        let (to, rev) = {",
      "            let _e = &mut self.g[self.pos[i].0][self.pos[i].1];",
      "            _e.cap = new_cap - new_flow;",
      "            (_e.to, _e.rev)",
      "        };",
      "        let _re = &mut self.g[to][rev];",
      "        _re.cap = new_flow;",
      "    }",
      "    fn flow(&mut self, s: usize, t: usize) -> i64 {",
      "        self.flow_with_capacity(s, t, std::i64::MAX)",
      "    }",
      "    fn flow_with_capacity(&mut self, s: usize, t: usize, flow_limit: i64) -> i64 {",
      "        assert!(s < self._n);",
      "        assert!(t < self._n);",
      "        assert_ne!(s, t);",
      "        assert!(0 <= flow_limit);",
      "        let n = self._n;",
      "        let mut d = Dinic {",
      "            n,",
      "            edge: &mut self.g,",
      "            iter: vec![0; n],",
      "            level: vec![-1; n],",
      "        };",
      "        d.calc(s, t, flow_limit)",
      "    }",
      "    fn min_cut(&self, s: usize) -> Vec<bool> {",
      "        let mut visited = vec![false; self._n];",
      "        let mut q = VecDeque::new();",
      "        q.push_back(s);",
      "        visited[s] = true;",
      "        while let Some(v) = q.pop_front() {",
      "            for &_Edge { to, cap, .. } in self.g[v].iter() {",
      "                if cap != 0 && !visited[to] {",
      "                    visited[to] = true;",
      "                    q.push_back(to);",
      "                }",
      "            }",
      "        }",
      "        visited",
      "    }",
      "}",
      "struct Dinic<'a> {",
      "    n: usize,",
      "    edge: &'a mut Vec<Vec<_Edge>>,",
      "    iter: Vec<usize>,",
      "    level: Vec<isize>,",
      "}",
      "impl Dinic<'_> {",
      "    fn dfs(&mut self, v: usize, t: usize, f: i64) -> Option<i64> {",
      "        if v == t {",
      "            Some(f)",
      "        } else {",
      "            while self.iter[v] < self.edge[v].len() {",
      "                let i = self.iter[v];",
      "                let _Edge { to: u, cap, rev } = self.edge[v][i];",
      "                if cap > 0 && self.level[v] < self.level[u] {",
      "                    if let Some(d) = self.dfs(u, t, min(f, cap)) {",
      "                        self.edge[v][i].cap -= d;",
      "                        self.edge[u][rev].cap += d;",
      "                        return Some(d);",
      "                    }",
      "                }",
      "                self.iter[v] += 1;",
      "            }",
      "            None",
      "        }",
      "    }",
      "    fn bfs(&mut self, s: usize) {",
      "        let mut q = VecDeque::new();",
      "        self.level[s] = 0;",
      "        q.push_back(s);",
      "        while let Some(v) = q.pop_front() {",
      "            for &_Edge { to, cap, .. } in self.edge[v].iter() {",
      "                if cap > 0 && self.level[to] < 0 {",
      "                    self.level[to] = self.level[v] + 1;",
      "                    q.push_back(to);",
      "                }",
      "            }",
      "        }",
      "    }",
      "    fn calc(&mut self, s: usize, t: usize, flow_limit: i64) -> i64 {",
      "        let mut flow = 0;",
      "        while flow < flow_limit {",
      "            self.level = vec![-1; self.n];",
      "            self.bfs(s);",
      "            if self.level[t] < 0 {",
      "                break;",
      "            }",
      "            self.iter = vec![0; self.n];",
      "            while let Some(f) = self.dfs(s, t, flow_limit - flow) {",
      "                flow += f;",
      "            }",
      "        }",
      "        flow",
      "    }",
      "}"
    ]
  },
  "MinFloat": {
    "prefix": "MinFloat",
    "body": [
      "pub trait Monoid {",
      "    fn id() -> Self;",
      "    fn f(a: Self, b: Self) -> Self;",
      "}",
      "#[derive(Debug, Copy, Clone, PartialEq)]",
      "pub enum MinFloat {",
      "    Val(f64),",
      "    Maximal,",
      "}",
      "impl Eq for MinFloat {}",
      "impl MinFloat {",
      "    pub fn unwrap(self) -> f64 {",
      "        if let Self::Val(x) = self {",
      "            x",
      "        } else {",
      "            panic!();",
      "        }",
      "    }",
      "    pub fn map<F>(self, f: F) -> Self",
      "    where",
      "        F: Fn(f64) -> f64,",
      "    {",
      "        if let Self::Val(x) = self {",
      "            Self::Val(f(x))",
      "        } else {",
      "            Self::Maximal",
      "        }",
      "    }",
      "}",
      "impl std::cmp::PartialOrd for MinFloat {",
      "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {",
      "        match (self, other) {",
      "            (&Self::Val(x), &Self::Val(y)) => x.partial_cmp(&y),",
      "            (&Self::Val(_), &Self::Maximal) => Some(Ordering::Less),",
      "            (&Self::Maximal, &Self::Val(_)) => Some(Ordering::Greater),",
      "            _ => Some(Ordering::Equal),",
      "        }",
      "    }",
      "}",
      "impl std::cmp::Ord for MinFloat {",
      "    fn cmp(&self, other: &Self) -> Ordering {",
      "        self.partial_cmp(other).unwrap()",
      "    }",
      "}",
      "impl std::ops::MulAssign<MinFloat> for MinFloat {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        if *self > rhs {",
      "            *self = rhs;",
      "        }",
      "    }",
      "}",
      "impl std::ops::Mul for MinFloat {",
      "    type Output = Self;",
      "    fn mul(self, other: Self) -> Self {",
      "        if self > other {",
      "            self",
      "        } else {",
      "            other",
      "        }",
      "    }",
      "}",
      "impl Monoid for MinFloat {",
      "    fn id() -> Self {",
      "        MinFloat::Maximal",
      "    }",
      "    fn f(a: Self, b: Self) -> Self {",
      "        a * b",
      "    }",
      "}"
    ]
  },
  "MinInt": {
    "prefix": "MinInt",
    "body": [
      "pub trait Monoid {",
      "    fn id() -> Self;",
      "    fn f(a: Self, b: Self) -> Self;",
      "}",
      "#[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord)]",
      "pub enum MinInt {",
      "    Val(i64),",
      "    Maximal,",
      "}",
      "#[allow(dead_code)]",
      "impl MinInt {",
      "    fn unwrap(self) -> i64 {",
      "        if let Self::Val(x) = self {",
      "            x",
      "        } else {",
      "            panic!();",
      "        }",
      "    }",
      "    fn map<F>(self, f: F) -> Self",
      "    where",
      "        F: Fn(i64) -> i64,",
      "    {",
      "        if let Self::Val(x) = self {",
      "            Self::Val(f(x))",
      "        } else {",
      "            Self::Maximal",
      "        }",
      "    }",
      "    fn map2<F>(self, b: Self, f: F) -> Self",
      "    where",
      "        F: Fn(i64, i64) -> i64,",
      "    {",
      "        match (self, b) {",
      "            (Self::Val(x), Self::Val(y)) => Self::Val(f(x, y)),",
      "            _ => Self::Maximal,",
      "        }",
      "    }",
      "    fn get_or(self, default: i64) -> i64 {",
      "        if let Self::Val(x) = self {",
      "            x",
      "        } else {",
      "            default",
      "        }",
      "    }",
      "}",
      "impl std::ops::Mul for MinInt {",
      "    type Output = Self;",
      "    fn mul(self, other: Self) -> Self {",
      "        if self < other {",
      "            self",
      "        } else {",
      "            other",
      "        }",
      "    }",
      "}",
      "impl Monoid for MinInt {",
      "    fn id() -> Self {",
      "        MinInt::Maximal",
      "    }",
      "    fn f(a: Self, b: Self) -> Self {",
      "        a * b",
      "    }",
      "}"
    ]
  },
  "Mint": {
    "prefix": "Mint",
    "body": [
      "const MOD: i64 = 1000000007;",
      "#[derive(Copy, Clone, Debug)]",
      "pub struct Mint(i64);",
      "impl Mint {",
      "    pub fn new(x: i64) -> Self {",
      "        Mint(x.rem_euclid(MOD))",
      "    }",
      "    pub fn pow(self, n: usize) -> Self {",
      "        match n {",
      "            0 => Mint::new(1),",
      "            _ => {",
      "                let mut a = self.pow(n >> 1);",
      "                a *= a;",
      "                if n & 1 == 1 {",
      "                    a *= self;",
      "                }",
      "                a",
      "            }",
      "        }",
      "    }",
      "    pub fn inv(self) -> Self {",
      "        self.pow((MOD - 2) as usize)",
      "    }",
      "}",
      "impl std::ops::Neg for Mint {",
      "    type Output = Mint;",
      "    fn neg(self) -> Self::Output {",
      "        Self::new(-self.0)",
      "    }",
      "}",
      "impl std::ops::AddAssign<Mint> for Mint {",
      "    fn add_assign(&mut self, Mint(rhs): Self) {",
      "        self.0 += rhs;",
      "        self.0 %= MOD;",
      "    }",
      "}",
      "impl std::ops::AddAssign<i64> for Mint {",
      "    fn add_assign(&mut self, rhs: i64) {",
      "        *self += Mint::new(rhs);",
      "    }",
      "}",
      "impl<T> std::ops::Add<T> for Mint",
      "where",
      "    Mint: std::ops::AddAssign<T>,",
      "{",
      "    type Output = Self;",
      "    fn add(self, other: T) -> Self {",
      "        let mut res = self;",
      "        res += other;",
      "        res",
      "    }",
      "}",
      "impl std::ops::SubAssign<Mint> for Mint {",
      "    fn sub_assign(&mut self, Mint(rhs): Self) {",
      "        self.0 -= rhs;",
      "        if self.0 < 0 {",
      "            self.0 += MOD;",
      "        }",
      "    }",
      "}",
      "impl std::ops::SubAssign<i64> for Mint {",
      "    fn sub_assign(&mut self, rhs: i64) {",
      "        *self -= Mint::new(rhs);",
      "    }",
      "}",
      "impl<T> std::ops::Sub<T> for Mint",
      "where",
      "    Mint: std::ops::SubAssign<T>,",
      "{",
      "    type Output = Self;",
      "    fn sub(self, other: T) -> Self {",
      "        let mut res = self;",
      "        res -= other;",
      "        res",
      "    }",
      "}",
      "impl std::ops::MulAssign<Mint> for Mint {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        self.0 *= rhs.0;",
      "        self.0 %= MOD;",
      "    }",
      "}",
      "impl std::ops::MulAssign<i64> for Mint {",
      "    fn mul_assign(&mut self, rhs: i64) {",
      "        *self *= Mint::new(rhs);",
      "    }",
      "}",
      "impl<T> std::ops::Mul<T> for Mint",
      "where",
      "    Mint: std::ops::MulAssign<T>,",
      "{",
      "    type Output = Self;",
      "    fn mul(self, other: T) -> Self {",
      "        let mut res = self;",
      "        res *= other;",
      "        res",
      "    }",
      "}",
      "#[allow(clippy::suspicious_op_assign_impl)]",
      "impl std::ops::DivAssign<Mint> for Mint {",
      "    fn div_assign(&mut self, rhs: Self) {",
      "        *self *= rhs.inv();",
      "    }",
      "}",
      "impl std::ops::DivAssign<i64> for Mint {",
      "    fn div_assign(&mut self, rhs: i64) {",
      "        *self /= Mint::new(rhs);",
      "    }",
      "}",
      "impl<T> std::ops::Div<T> for Mint",
      "where",
      "    Mint: std::ops::DivAssign<T>,",
      "{",
      "    type Output = Self;",
      "    fn div(self, other: T) -> Self {",
      "        let mut res = self;",
      "        res /= other;",
      "        res",
      "    }",
      "}",
      "impl std::fmt::Display for Mint {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        write!(f, \"{}\", self.0)",
      "    }",
      "}",
      "impl std::ops::Deref for Mint {",
      "    type Target = i64;",
      "    fn deref(&self) -> &Self::Target {",
      "        &self.0",
      "    }",
      "}",
      "impl std::ops::DerefMut for Mint {",
      "    fn deref_mut(&mut self) -> &mut Self::Target {",
      "        &mut self.0",
      "    }",
      "}"
    ]
  },
  "Mint_Static": {
    "prefix": "Mint_Static",
    "body": [
      "static mut MOD: i64 = 1000000007;",
      "#[derive(Copy, Clone, Debug)]",
      "pub struct Mint(i64);",
      "impl Mint {",
      "    pub fn new(x: i64) -> Self {",
      "        unsafe { Mint(x.rem_euclid(MOD)) }",
      "    }",
      "    pub fn modulo(m: i64) {",
      "        unsafe {",
      "            MOD = m;",
      "        }",
      "    }",
      "    pub fn pow(self, n: usize) -> Self {",
      "        match n {",
      "            0 => Mint::new(1),",
      "            _ => {",
      "                let mut a = self.pow(n >> 1);",
      "                a *= a;",
      "                if n & 1 == 1 {",
      "                    a *= self;",
      "                }",
      "                a",
      "            }",
      "        }",
      "    }",
      "    pub fn inv(self) -> Self {",
      "        unsafe { self.pow((MOD - 2) as usize) }",
      "    }",
      "}",
      "impl std::ops::Neg for Mint {",
      "    type Output = Mint;",
      "    fn neg(self) -> Self::Output {",
      "        Self::new(-self.0)",
      "    }",
      "}",
      "impl std::ops::AddAssign<Mint> for Mint {",
      "    fn add_assign(&mut self, rhs: Self) {",
      "        self.0 += rhs.0;",
      "        unsafe {",
      "            self.0 %= MOD;",
      "        }",
      "    }",
      "}",
      "impl std::ops::AddAssign<i64> for Mint {",
      "    fn add_assign(&mut self, rhs: i64) {",
      "        *self += Mint::new(rhs);",
      "    }",
      "}",
      "impl<T> std::ops::Add<T> for Mint",
      "where",
      "    Mint: std::ops::AddAssign<T>,",
      "{",
      "    type Output = Self;",
      "    fn add(self, other: T) -> Self {",
      "        let mut res = self;",
      "        res += other;",
      "        res",
      "    }",
      "}",
      "impl std::ops::SubAssign<Mint> for Mint {",
      "    fn sub_assign(&mut self, rhs: Self) {",
      "        self.0 -= rhs.0;",
      "        if self.0 < 0 {",
      "            unsafe {",
      "                self.0 += MOD;",
      "            }",
      "        }",
      "    }",
      "}",
      "impl std::ops::SubAssign<i64> for Mint {",
      "    fn sub_assign(&mut self, rhs: i64) {",
      "        *self -= Mint::new(rhs);",
      "    }",
      "}",
      "impl<T> std::ops::Sub<T> for Mint",
      "where",
      "    Mint: std::ops::SubAssign<T>,",
      "{",
      "    type Output = Self;",
      "    fn sub(self, other: T) -> Self {",
      "        let mut res = self;",
      "        res -= other;",
      "        res",
      "    }",
      "}",
      "impl std::ops::MulAssign<Mint> for Mint {",
      "    fn mul_assign(&mut self, rhs: Self) {",
      "        self.0 *= rhs.0;",
      "        unsafe {",
      "            self.0 %= MOD;",
      "        }",
      "    }",
      "}",
      "impl std::ops::MulAssign<i64> for Mint {",
      "    fn mul_assign(&mut self, rhs: i64) {",
      "        *self *= Mint::new(rhs);",
      "    }",
      "}",
      "impl<T> std::ops::Mul<T> for Mint",
      "where",
      "    Mint: std::ops::MulAssign<T>,",
      "{",
      "    type Output = Self;",
      "    fn mul(self, other: T) -> Self {",
      "        let mut res = self;",
      "        res *= other;",
      "        res",
      "    }",
      "}",
      "#[allow(clippy::suspicious_op_assign_impl)]",
      "impl std::ops::DivAssign<Mint> for Mint {",
      "    fn div_assign(&mut self, rhs: Self) {",
      "        *self *= rhs.inv();",
      "    }",
      "}",
      "impl std::ops::DivAssign<i64> for Mint {",
      "    fn div_assign(&mut self, rhs: i64) {",
      "        *self /= Mint::new(rhs);",
      "    }",
      "}",
      "impl<T> std::ops::Div<T> for Mint",
      "where",
      "    Mint: std::ops::DivAssign<T>,",
      "{",
      "    type Output = Self;",
      "    fn div(self, other: T) -> Self {",
      "        let mut res = self;",
      "        res /= other;",
      "        res",
      "    }",
      "}",
      "impl std::fmt::Display for Mint {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        write!(f, \"{}\", self.0)",
      "    }",
      "}",
      "impl std::ops::Deref for Mint {",
      "    type Target = i64;",
      "    fn deref(&self) -> &Self::Target {",
      "        &self.0",
      "    }",
      "}",
      "impl std::ops::DerefMut for Mint {",
      "    fn deref_mut(&mut self) -> &mut Self::Target {",
      "        &mut self.0",
      "    }",
      "}"
    ]
  },
  "Monoid": {
    "prefix": "Monoid",
    "body": [
      "pub trait Monoid {",
      "    fn id() -> Self;",
      "    fn f(a: Self, b: Self) -> Self;",
      "}"
    ]
  },
  "Mpow": {
    "prefix": "Mpow",
    "body": [
      "pub fn mpow(a: usize, n: usize, m: usize) -> usize {",
      "    match n {",
      "        0 => 1,",
      "        _ => {",
      "            let mut x = mpow(a, n >> 1, m);",
      "            x *= x;",
      "            x %= m;",
      "            if n & 1 == 1 {",
      "                x *= a;",
      "                x %= m;",
      "            }",
      "            x",
      "        }",
      "    }",
      "}"
    ]
  },
  "P2d": {
    "prefix": "P2d",
    "body": [
      "use std::ops::*;",
      "#[derive(Debug, Copy, Clone, PartialEq, PartialOrd)]",
      "pub struct Point2d<T> {",
      "    x: T,",
      "    y: T,",
      "}",
      "impl<T: Add<Output = T>> Add for Point2d<T> {",
      "    type Output = Point2d<T>;",
      "    fn add(self, other: Self) -> Self::Output {",
      "        Point2d {",
      "            x: self.x + other.x,",
      "            y: self.y + other.y,",
      "        }",
      "    }",
      "}",
      "impl<T: Sub<Output = T>> Sub for Point2d<T> {",
      "    type Output = Point2d<T>;",
      "    fn sub(self, other: Self) -> Self::Output {",
      "        Point2d {",
      "            x: self.x - other.x,",
      "            y: self.y - other.y,",
      "        }",
      "    }",
      "}",
      "impl<T: Copy + Clone + Mul<Output = T>> Mul<T> for Point2d<T> {",
      "    type Output = Point2d<T>;",
      "    fn mul(self, other: T) -> Self::Output {",
      "        Point2d {",
      "            x: self.x * other,",
      "            y: self.y * other,",
      "        }",
      "    }",
      "}",
      "impl<T: Copy + Clone + Div<Output = T>> Div<T> for Point2d<T> {",
      "    type Output = Point2d<T>;",
      "    fn div(self, other: T) -> Self::Output {",
      "        Point2d {",
      "            x: self.x / other,",
      "            y: self.y / other,",
      "        }",
      "    }",
      "}",
      "impl<T: Copy + Clone + Add<Output = T> + Mul<Output = T>> Point2d<T> {",
      "    pub fn new(x: T, y: T) -> Self {",
      "        Point2d { x, y }",
      "    }",
      "    pub fn dot(self, other: Self) -> T {",
      "        self.x * other.x + self.y * other.y",
      "    }",
      "    pub fn pow(self) -> T {",
      "        self.dot(self)",
      "    }",
      "}"
    ]
  },
  "P2dFloat": {
    "prefix": "P2dFloat",
    "body": [
      "use std::ops::*;",
      "#[derive(Debug, Copy, Clone, PartialEq, PartialOrd)]",
      "pub struct Point2d<T> {",
      "    x: T,",
      "    y: T,",
      "}",
      "impl<T: Add<Output = T>> Add for Point2d<T> {",
      "    type Output = Point2d<T>;",
      "    fn add(self, other: Self) -> Self::Output {",
      "        Point2d {",
      "            x: self.x + other.x,",
      "            y: self.y + other.y,",
      "        }",
      "    }",
      "}",
      "impl<T: Sub<Output = T>> Sub for Point2d<T> {",
      "    type Output = Point2d<T>;",
      "    fn sub(self, other: Self) -> Self::Output {",
      "        Point2d {",
      "            x: self.x - other.x,",
      "            y: self.y - other.y,",
      "        }",
      "    }",
      "}",
      "impl<T: Copy + Clone + Mul<Output = T>> Mul<T> for Point2d<T> {",
      "    type Output = Point2d<T>;",
      "    fn mul(self, other: T) -> Self::Output {",
      "        Point2d {",
      "            x: self.x * other,",
      "            y: self.y * other,",
      "        }",
      "    }",
      "}",
      "impl<T: Copy + Clone + Div<Output = T>> Div<T> for Point2d<T> {",
      "    type Output = Point2d<T>;",
      "    fn div(self, other: T) -> Self::Output {",
      "        Point2d {",
      "            x: self.x / other,",
      "            y: self.y / other,",
      "        }",
      "    }",
      "}",
      "impl<T: Copy + Clone + Add<Output = T> + Mul<Output = T>> Point2d<T> {",
      "    pub fn new(x: T, y: T) -> Self {",
      "        Point2d { x, y }",
      "    }",
      "    pub fn dot(self, other: Self) -> T {",
      "        self.x * other.x + self.y * other.y",
      "    }",
      "    pub fn pow(self) -> T {",
      "        self.dot(self)",
      "    }",
      "}",
      "impl Point2d<f64> {",
      "    pub fn abs(self) -> f64 {",
      "        self.dot(self).sqrt()",
      "    }",
      "    pub fn rot(self, theta: f64) -> Self {",
      "        Point2d {",
      "            x: self.x * theta.cos() - self.y * theta.sin(),",
      "            y: self.x * theta.sin() + self.y * theta.cos(),",
      "        }",
      "    }",
      "}"
    ]
  },
  "P3d": {
    "prefix": "P3d",
    "body": [
      "#[derive(Debug, Copy, Clone, PartialEq, PartialOrd)]",
      "pub struct Point3d<T> {",
      "    x: T,",
      "    y: T,",
      "    z: T,",
      "}",
      "impl<T: Add<Output = T>> Add for Point3d<T> {",
      "    type Output = Point3d<T>;",
      "    fn add(self, other: Self) -> Self::Output {",
      "        Point3d {",
      "            x: self.x + other.x,",
      "            y: self.y + other.y,",
      "            z: self.z + other.z,",
      "        }",
      "    }",
      "}",
      "impl<T: Sub<Output = T>> Sub for Point3d<T> {",
      "    type Output = Point3d<T>;",
      "    fn sub(self, other: Self) -> Self::Output {",
      "        Point3d {",
      "            x: self.x - other.x,",
      "            y: self.y - other.y,",
      "            z: self.z - other.z,",
      "        }",
      "    }",
      "}",
      "impl<T: Copy + Clone + Mul<Output = T>> Mul<T> for Point3d<T> {",
      "    type Output = Point3d<T>;",
      "    fn mul(self, other: T) -> Self::Output {",
      "        Point3d {",
      "            x: self.x * other,",
      "            y: self.y * other,",
      "            z: self.z * other,",
      "        }",
      "    }",
      "}",
      "impl<T: Copy + Clone + Div<Output = T>> Div<T> for Point3d<T> {",
      "    type Output = Point3d<T>;",
      "    fn div(self, other: T) -> Self::Output {",
      "        Point3d {",
      "            x: self.x / other,",
      "            y: self.y / other,",
      "            z: self.z / other,",
      "        }",
      "    }",
      "}",
      "impl<T: Copy + Clone + Add<Output = T> + Mul<Output = T>> Point3d<T> {",
      "    pub fn new(x: T, y: T, z: T) -> Self {",
      "        Point3d { x, y, z }",
      "    }",
      "    pub fn dot(self, other: Self) -> T {",
      "        self.x * other.x + self.y * other.y + self.z * other.z",
      "    }",
      "    pub fn pow(self) -> T {",
      "        self.dot(self)",
      "    }",
      "}"
    ]
  },
  "P3dFloat": {
    "prefix": "P3dFloat",
    "body": [
      "#[derive(Debug, Copy, Clone, PartialEq, PartialOrd)]",
      "pub struct Point3d<T> {",
      "    x: T,",
      "    y: T,",
      "    z: T,",
      "}",
      "impl<T: Add<Output = T>> Add for Point3d<T> {",
      "    type Output = Point3d<T>;",
      "    fn add(self, other: Self) -> Self::Output {",
      "        Point3d {",
      "            x: self.x + other.x,",
      "            y: self.y + other.y,",
      "            z: self.z + other.z,",
      "        }",
      "    }",
      "}",
      "impl<T: Sub<Output = T>> Sub for Point3d<T> {",
      "    type Output = Point3d<T>;",
      "    fn sub(self, other: Self) -> Self::Output {",
      "        Point3d {",
      "            x: self.x - other.x,",
      "            y: self.y - other.y,",
      "            z: self.z - other.z,",
      "        }",
      "    }",
      "}",
      "impl<T: Copy + Clone + Mul<Output = T>> Mul<T> for Point3d<T> {",
      "    type Output = Point3d<T>;",
      "    fn mul(self, other: T) -> Self::Output {",
      "        Point3d {",
      "            x: self.x * other,",
      "            y: self.y * other,",
      "            z: self.z * other,",
      "        }",
      "    }",
      "}",
      "impl<T: Copy + Clone + Div<Output = T>> Div<T> for Point3d<T> {",
      "    type Output = Point3d<T>;",
      "    fn div(self, other: T) -> Self::Output {",
      "        Point3d {",
      "            x: self.x / other,",
      "            y: self.y / other,",
      "            z: self.z / other,",
      "        }",
      "    }",
      "}",
      "impl<T: Copy + Clone + Add<Output = T> + Mul<Output = T>> Point3d<T> {",
      "    pub fn new(x: T, y: T, z: T) -> Self {",
      "        Point3d { x, y, z }",
      "    }",
      "    pub fn dot(self, other: Self) -> T {",
      "        self.x * other.x + self.y * other.y + self.z * other.z",
      "    }",
      "    pub fn pow(self) -> T {",
      "        self.dot(self)",
      "    }",
      "}",
      "impl Point3d<f64> {",
      "    pub fn abs(self) -> f64 {",
      "        self.dot(self).sqrt()",
      "    }",
      "}"
    ]
  },
  "Permutation": {
    "prefix": "Permutation",
    "body": [
      "pub trait LexicalPermutation {",
      "    fn next_permutation(&mut self) -> bool;",
      "    fn prev_permutation(&mut self) -> bool;",
      "}",
      "impl<T> LexicalPermutation for [T]",
      "where",
      "    T: Ord,",
      "{",
      "    fn next_permutation(&mut self) -> bool {",
      "        if self.len() < 2 {",
      "            return false;",
      "        }",
      "        let mut i = self.len() - 1;",
      "        while i > 0 && self[i - 1] >= self[i] {",
      "            i -= 1;",
      "        }",
      "        if i == 0 {",
      "            return false;",
      "        }",
      "        let mut j = self.len() - 1;",
      "        while j >= i && self[j] <= self[i - 1] {",
      "            j -= 1;",
      "        }",
      "        self.swap(j, i - 1);",
      "        self[i..].reverse();",
      "        true",
      "    }",
      "    fn prev_permutation(&mut self) -> bool {",
      "        if self.len() < 2 {",
      "            return false;",
      "        }",
      "        let mut i = self.len() - 1;",
      "        while i > 0 && self[i - 1] <= self[i] {",
      "            i -= 1;",
      "        }",
      "        if i == 0 {",
      "            return false;",
      "        }",
      "        self[i..].reverse();",
      "        let mut j = self.len() - 1;",
      "        while j >= i && self[j - 1] < self[i - 1] {",
      "            j -= 1;",
      "        }",
      "        self.swap(i - 1, j);",
      "        true",
      "    }",
      "}"
    ]
  },
  "RationalNumber": {
    "prefix": "RationalNumber",
    "body": [
      "#[derive(Debug, Copy, Clone, PartialEq, Eq)]",
      "pub struct Quotient {",
      "    a: i64,",
      "    b: i64,",
      "}",
      "pub fn euk(a: i64, b: i64) -> i64 {",
      "    if b == 0 {",
      "        a",
      "    } else {",
      "        euk(b, a % b)",
      "    }",
      "}",
      "impl Quotient {",
      "    pub fn new(a: i64, b: i64) -> Self {",
      "        let m = euk(a, b);",
      "        match b {",
      "            0 => unreachable!(),",
      "            x if x < 0 => Quotient {",
      "                a: -a / m,",
      "                b: -b / m,",
      "            },",
      "            _ => Quotient { a: a / m, b: b / m },",
      "        }",
      "    }",
      "}",
      "impl PartialOrd for Quotient {",
      "    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {",
      "        (self.a * other.b).partial_cmp(&(other.a * self.b))",
      "    }",
      "}",
      "impl Ord for Quotient {",
      "    fn cmp(&self, other: &Self) -> Ordering {",
      "        self.partial_cmp(other).unwrap()",
      "    }",
      "}",
      "impl std::ops::Add for Quotient {",
      "    type Output = Self;",
      "    fn add(self, other: Self) -> Self::Output {",
      "        let a = other.b * self.a + self.b * other.a;",
      "        let b = self.b * other.b;",
      "        let c = euk(a.abs(), b);",
      "        Quotient { a: a / c, b: b / c }",
      "    }",
      "}",
      "impl std::ops::Sub for Quotient {",
      "    type Output = Self;",
      "    fn sub(self, other: Self) -> Self::Output {",
      "        let a = other.b * self.a - self.b * other.a;",
      "        let b = self.b * other.b;",
      "        let c = euk(a.abs(), b);",
      "        Quotient { a: a / c, b: b / c }",
      "    }",
      "}",
      "impl std::ops::Neg for Quotient {",
      "    type Output = Self;",
      "    fn neg(self) -> Self {",
      "        Quotient {",
      "            a: -self.a,",
      "            b: self.b,",
      "        }",
      "    }",
      "}",
      "impl std::ops::Mul for Quotient {",
      "    type Output = Self;",
      "    fn mul(self, other: Self) -> Self::Output {",
      "        let a = self.a * other.a;",
      "        let b = self.b * other.b;",
      "        let c = euk(a.abs(), b);",
      "        Quotient { a: a / c, b: b / c }",
      "    }",
      "}",
      "impl std::ops::Div for Quotient {",
      "    type Output = Self;",
      "    fn div(self, other: Self) -> Self::Output {",
      "        if other.a == 0 {",
      "            panic!()",
      "        }",
      "        let a = self.a * other.b;",
      "        let b = self.b * other.a;",
      "        let c = euk(a.abs(), b.abs());",
      "        if b < 0 {",
      "            Quotient {",
      "                a: -a / c,",
      "                b: -b / c,",
      "            }",
      "        } else {",
      "            Quotient { a: a / c, b: b / c }",
      "        }",
      "    }",
      "}"
    ]
  },
  "Rerooting": {
    "prefix": "Rerooting",
    "body": [
      "pub struct N;",
      "impl Node for N {",
      "    type T = i64;",
      "    fn id() -> Self::T {",
      "        1",
      "    }",
      "    fn add_root(v: &Self::T) -> Self::T {",
      "        *v + 1",
      "    }",
      "    fn add(v: &Self::T, u: &Self::T) -> Self::T {",
      "        *v * *u",
      "    }",
      "}",
      "pub trait Node {",
      "    type T: Clone;",
      "    fn id() -> Self::T;",
      "    fn add_root(v: &Self::T) -> Self::T;",
      "    fn add(v: &Self::T, u: &Self::T) -> Self::T;",
      "}",
      "pub struct Rerooting<N: Node> {",
      "    to: Vec<Vec<usize>>,",
      "    dp: Vec<Vec<N::T>>,",
      "    ans: Vec<N::T>,",
      "}",
      "impl<N: Node> Rerooting<N> {",
      "    pub fn new(n: usize) -> Self {",
      "        Rerooting {",
      "            to: vec![Vec::<usize>::new(); n],",
      "            dp: vec![Vec::<N::T>::new(); n],",
      "            ans: vec![N::id(); n],",
      "        }",
      "    }",
      "    pub fn add_edge(&mut self, u: usize, v: usize) {",
      "        self.to[u].push(v);",
      "        self.to[v].push(u);",
      "    }",
      "    pub fn init(&mut self) {",
      "        self.dfs(0, None);",
      "        self.bfs(0, N::id(), None);",
      "    }",
      "    pub fn dfs(&mut self, v: usize, p: Option<usize>) -> N::T {",
      "        let mut dp_sum = N::id();",
      "        let deg = self.to[v].len();",
      "        self.dp[v] = vec![N::id(); deg];",
      "        for i in 0..deg {",
      "            let u = self.to[v][i];",
      "            if Some(u) == p {",
      "                continue;",
      "            }",
      "            self.dp[v][i] = self.dfs(u, Some(v));",
      "            dp_sum = N::add(&dp_sum, &self.dp[v][i]);",
      "        }",
      "        N::add_root(&dp_sum)",
      "    }",
      "    pub fn bfs(&mut self, v: usize, dp_p: N::T, p: Option<usize>) {",
      "        if let Some(p) = p {",
      "            let x = self.to[v].iter().enumerate().find(|&(_, v)| *v == p);",
      "            if let Some((i, _)) = x {",
      "                self.dp[v][i] = dp_p;",
      "            }",
      "        }",
      "        let deg = self.to[v].len();",
      "        let mut dp_sum_l = vec![N::id(); deg + 1];",
      "        for i in 0..deg {",
      "            dp_sum_l[i + 1] = N::add(&dp_sum_l[i], &self.dp[v][i]);",
      "        }",
      "        let mut dp_sum_r = vec![N::id(); deg + 1];",
      "        for i in (0..deg).rev() {",
      "            dp_sum_r[i] = N::add(&dp_sum_r[i + 1], &self.dp[v][i]);",
      "        }",
      "        self.ans[v] = N::add_root(&dp_sum_l[deg]);",
      "        for i in 0..deg {",
      "            let u = self.to[v][i];",
      "            if Some(u) == p {",
      "                continue;",
      "            }",
      "            self.bfs(",
      "                u,",
      "                N::add_root(&N::add(&dp_sum_l[i], &dp_sum_r[i + 1])),",
      "                Some(v),",
      "            );",
      "        }",
      "    }",
      "}"
    ]
  },
  "SCC": {
    "prefix": "SCC",
    "body": [
      "pub struct SCC {",
      "    n: usize,",
      "    edge: Vec<Vec<usize>>,",
      "    rev: Vec<Vec<usize>>,",
      "    num: Vec<usize>,",
      "    scc: Vec<Vec<usize>>,",
      "}",
      "impl SCC {",
      "    pub fn new(n: usize) -> Self {",
      "        SCC {",
      "            n,",
      "            edge: vec![vec![]; n],",
      "            rev: vec![vec![]; n],",
      "            num: vec![0; n],",
      "            scc: vec![],",
      "        }",
      "    }",
      "    pub fn add_edge(&mut self, u: usize, v: usize) {",
      "        self.edge[u].push(v);",
      "        self.rev[v].push(u);",
      "    }",
      "    pub fn init(&mut self) {",
      "        let mut num = 0;",
      "        let mut visited = vec![false; self.n];",
      "        for i in 0..self.n {",
      "            if visited[i] {",
      "                continue;",
      "            }",
      "            self.dfs(i, &mut visited, &mut num);",
      "        }",
      "        let mut idx: Vec<_> = (0..self.n).collect();",
      "        let mut visited = vec![false; self.n];",
      "        idx.sort_by_key(|&i| Reverse(self.num[i]));",
      "        for &v in idx.iter() {",
      "            if visited[v] {",
      "                continue;",
      "            }",
      "            let mut scc = vec![];",
      "            self.dfs2(v, &mut visited, &mut scc);",
      "            self.scc.push(scc);",
      "        }",
      "    }",
      "    pub fn dfs2(&mut self, v: usize, visited: &mut Vec<bool>, g: &mut Vec<usize>) {",
      "        let iter = self.rev[v].clone();",
      "        g.push(v);",
      "        visited[v] = true;",
      "        for u in iter {",
      "            if visited[u] {",
      "                continue;",
      "            }",
      "            self.dfs2(u, visited, g);",
      "        }",
      "    }",
      "    pub fn dfs(&mut self, v: usize, visited: &mut Vec<bool>, num: &mut usize) {",
      "        let iter = self.edge[v].clone();",
      "        visited[v] = true;",
      "        for u in iter {",
      "            if visited[u] {",
      "                continue;",
      "            }",
      "            self.dfs(u, visited, num);",
      "        }",
      "        self.num[v] = *num;",
      "        *num += 1;",
      "    }",
      "}"
    ]
  },
  "SaffixArray": {
    "prefix": "SaffixArray",
    "body": [
      "pub struct SaffixArray {",
      "    n: usize,",
      "    s: String,",
      "    sa: Vec<usize>,",
      "}",
      "pub fn compare_sa(rank: &[i64], n: usize, k: usize, i: usize, j: usize) -> std::cmp::Ordering {",
      "    if rank[i] != rank[j] {",
      "        rank[i].cmp(&rank[j])",
      "    } else {",
      "        let ri = if i + k <= n { rank[i + k] } else { -1 };",
      "        let rj = if j + k <= n { rank[j + k] } else { -1 };",
      "        ri.cmp(&rj)",
      "    }",
      "}",
      "impl SaffixArray {",
      "    pub fn construct(s: &str) -> Self {",
      "        let n = s.len();",
      "        let mut sa = (0..=n).collect::<Vec<usize>>();",
      "        let mut rank = s.as_bytes().iter().map(|&c| c as i64).collect::<Vec<i64>>();",
      "        rank.push(-1);",
      "        let mut k = 1;",
      "        let mut tmp = vec![0; n + 1];",
      "        while k <= n {",
      "            sa.sort_by(|a, b| compare_sa(&rank, n, k, *a, *b));",
      "            tmp[sa[0]] = 0;",
      "            for i in 1..=n {",
      "                tmp[sa[i]] = tmp[sa[i - 1]]",
      "                    + match compare_sa(&rank, n, k, sa[i - 1], sa[i]) {",
      "                        std::cmp::Ordering::Less => 1,",
      "                        _ => 0,",
      "                    };",
      "            }",
      "            rank[..=n].copy_from_slice(&tmp[..=n]);",
      "            k <<= 1;",
      "        }",
      "        SaffixArray {",
      "            n: s.len(),",
      "            s: s.to_string(),",
      "            sa,",
      "        }",
      "    }",
      "    pub fn contain(&self, t: &str) -> bool {",
      "        let mut low = 0;",
      "        let mut high = self.n;",
      "        let m = t.len();",
      "        while high - low > 1 {",
      "            let mid = (high + low) / 2;",
      "            if self.s[self.sa[mid]..self.sa[mid] + m] <= *t {",
      "                low = mid;",
      "            } else {",
      "                high = mid;",
      "            }",
      "        }",
      "        self.s[self.sa[low]..self.sa[low] + m] == *t",
      "    }",
      "}"
    ]
  },
  "SegmentTree": {
    "prefix": "SegmentTree",
    "body": [
      "struct SegmentTree<T, F: Fn(&T, &T) -> T> {",
      "    _n: usize,",
      "    width: usize,",
      "    node: Vec<T>,",
      "    id: T,",
      "    op: F,",
      "}",
      "#[allow(dead_code)]",
      "impl<T: Copy + Clone, F: Fn(&T, &T) -> T> SegmentTree<T, F> {",
      "    fn new(n: usize, id: T, op: F) -> Self {",
      "        let width = n.next_power_of_two();",
      "        Self {",
      "            _n: n,",
      "            width,",
      "            node: vec![id; width << 1],",
      "            id,",
      "            op,",
      "        }",
      "    }",
      "    fn from_vec(a: &[T], id: T, op: F) -> Self {",
      "        let _n = a.len();",
      "        let width = _n.next_power_of_two();",
      "        let mut node = vec![id; width << 1];",
      "        for i in 0.._n {",
      "            node[i + width] = a[i];",
      "        }",
      "        for i in (1..width).rev() {",
      "            node[i] = op(&node[i << 1], &node[1 + (i << 1)]);",
      "        }",
      "        Self {",
      "            _n,",
      "            width,",
      "            node,",
      "            id,",
      "            op,",
      "        }",
      "    }",
      "    fn update(&mut self, idx: usize, v: T) {",
      "        let mut now = idx + self.width;",
      "        self.node[now] = v;",
      "        now = now >> 1;",
      "        while now > 0 {",
      "            self.node[now] = (self.op)(&self.node[now << 1], &self.node[1 + (now << 1)]);",
      "            now = now >> 1;",
      "        }",
      "    }",
      "    fn get(&self, idx: usize) -> T {",
      "        self.node[idx + self.width]",
      "    }",
      "    fn __prod(&self, idx: usize, lc: usize, rc: usize, l: usize, r: usize) -> T {",
      "        if rc <= l || r <= lc {",
      "            self.id",
      "        } else if l <= lc && rc <= r {",
      "            self.node[idx]",
      "        } else {",
      "            (self.op)(",
      "                &self.__prod(idx << 1, lc, (lc + rc) / 2, l, r),",
      "                &self.__prod(1 + (idx << 1), (lc + rc) / 2, rc, l, r),",
      "            )",
      "        }",
      "    }",
      "    fn prod<R>(&self, range: R) -> T",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        let l = match range.start_bound() {",
      "            std::ops::Bound::Included(&a) => a,",
      "            _ => 0,",
      "        };",
      "        let r = match range.end_bound() {",
      "            std::ops::Bound::Excluded(&a) => a,",
      "            std::ops::Bound::Included(&a) => a + 1,",
      "            _ => self._n,",
      "        };",
      "        self.__prod(0, 0, 1 << self.width, l, r)",
      "    }",
      "    /// return Some(r): Max f(l..r) == true && f(l..=r) == false",
      "    fn max_right(&self, l: usize, f: fn(T) -> bool) -> Option<usize> {",
      "        if !f(self.get(l)) {",
      "            None",
      "        } else {",
      "            let mut low = l;",
      "            let mut high = self.width;",
      "            while high - low > 1 {",
      "                let mid = (low + high) / 2;",
      "                if f(self.prod(l..=mid)) {",
      "                    low = mid;",
      "                } else {",
      "                    high = mid;",
      "                }",
      "            }",
      "            Some(low)",
      "        }",
      "    }",
      "    /// return l: Min f(self.prod(l, r)) == true",
      "    fn min_left(&self, r: usize, f: fn(T) -> bool) -> Option<usize> {",
      "        if !f(self.get(r)) {",
      "            None",
      "        } else {",
      "            let mut low = 0;",
      "            let mut high = r;",
      "            while high - low > 1 {",
      "                let mid = (low + high) / 2;",
      "                if f(self.prod(mid..=r)) {",
      "                    high = mid;",
      "                } else {",
      "                    low = mid;",
      "                }",
      "            }",
      "            Some(high)",
      "        }",
      "    }",
      "}"
    ]
  },
  "SegmentTree_Monoid": {
    "prefix": "SegmentTree_Monoid",
    "body": [
      "struct Node;",
      "impl Monoid for Node {",
      "    type T = i64;",
      "    fn id() -> Self::T {",
      "        0",
      "    }",
      "    fn f(a: &Self::T, b: &Self::T) -> Self::T {",
      "        a + b",
      "    }",
      "}",
      "trait Monoid {",
      "    type T: Clone;",
      "    fn id() -> Self::T;",
      "    fn f(a: &Self::T, b: &Self::T) -> Self::T;",
      "}",
      "struct SegmentTree<M: Monoid> {",
      "    _n: usize,",
      "    width: usize,",
      "    node: Vec<M::T>,",
      "}",
      "#[allow(dead_code)]",
      "impl<M: Monoid> SegmentTree<M> {",
      "    fn new(n: usize) -> Self {",
      "        let width = n.next_power_of_two();",
      "        Self {",
      "            _n: n,",
      "            width,",
      "            node: vec![M::id(); width << 1],",
      "        }",
      "    }",
      "    fn from_vec(a: &[M::T]) -> Self {",
      "        let _n = a.len();",
      "        let width = _n.next_power_of_two();",
      "        let mut node = vec![M::id(); width << 1];",
      "        node[width..width + _n].clone_from_slice(&a[0.._n]);",
      "        for i in (1..width).rev() {",
      "            node[i] = M::f(&node[i << 1], &node[1 + (i << 1)]);",
      "        }",
      "        Self { _n, width, node }",
      "    }",
      "    fn update(&mut self, idx: usize, v: M::T) {",
      "        assert!(idx < self._n);",
      "        let mut now = idx + self.width;",
      "        self.node[now] = v;",
      "        now >>= 1;",
      "        while now > 0 {",
      "            self.node[now] = M::f(&self.node[now << 1], &self.node[1 + (now << 1)]);",
      "            now >>= 1;",
      "        }",
      "    }",
      "    fn get(&self, idx: usize) -> M::T {",
      "        self.node[idx + self.width].clone()",
      "    }",
      "    fn prod<R>(&self, range: R) -> M::T",
      "    where",
      "        R: std::ops::RangeBounds<usize>,",
      "    {",
      "        let mut l = match range.start_bound() {",
      "            std::ops::Bound::Included(&a) => a,",
      "            _ => 0,",
      "        } + self.width;",
      "        let mut r = match range.end_bound() {",
      "            std::ops::Bound::Excluded(&a) => a,",
      "            std::ops::Bound::Included(&a) => a + 1,",
      "            _ => self._n,",
      "        } + self.width;",
      "        assert!(r <= self._n + self.width);",
      "        let mut x = M::id();",
      "        let mut y = M::id();",
      "        while l < r {",
      "            if l & 1 == 1 {",
      "                x = M::f(&x, &self.node[l]);",
      "                l += 1;",
      "            }",
      "            if r & 1 == 1 {",
      "                r -= 1;",
      "                y = M::f(&self.node[r], &y);",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        M::f(&x, &y)",
      "    }",
      "}"
    ]
  },
  "UnionFind": {
    "prefix": "UnionFind",
    "body": [
      "pub struct UnionFind {",
      "    par: Vec<usize>,",
      "    rank: Vec<usize>,",
      "}",
      "impl UnionFind {",
      "    pub fn new(n: usize) -> Self {",
      "        UnionFind {",
      "            par: (0..n).collect(),",
      "            rank: vec![1; n],",
      "        }",
      "    }",
      "    pub fn unite(&mut self, x: usize, y: usize) {",
      "        if self.same(x, y) {",
      "            return;",
      "        }",
      "        let rx = self.par[x];",
      "        let ry = self.par[y];",
      "        if self.rank[rx] > self.rank[ry] {",
      "            self.par[ry] = rx;",
      "            self.rank[rx] += self.rank[ry];",
      "        } else {",
      "            self.par[rx] = ry;",
      "            self.rank[ry] += self.rank[rx];",
      "        }",
      "    }",
      "    pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "        self.root(x) == self.root(y)",
      "    }",
      "    pub fn root(&mut self, x: usize) -> usize {",
      "        if self.par[x] == x {",
      "            x",
      "        } else {",
      "            self.par[x] = self.root(self.par[x]);",
      "            self.par[x]",
      "        }",
      "    }",
      "    pub fn size(&mut self, x: usize) -> usize {",
      "        let r = self.root(x);",
      "        self.rank[r]",
      "    }",
      "}"
    ]
  },
  "floor_sum": {
    "prefix": "floor_sum",
    "body": [
      "/// return ∑ floor[(a * i + b) / m] for i in [0, n)",
      "pub fn floor_sum(n: i64, m: i64, mut a: i64, mut b: i64) -> i64 {",
      "    let mut ans = 0;",
      "    if a >= m {",
      "        ans += (n - 1) * n * (a / m) / 2;",
      "        a %= m;",
      "    }",
      "    if b >= m {",
      "        ans += n * (b / m);",
      "        b %= m;",
      "    }",
      "    let y_max = (a * n + b) / m;",
      "    let x_max = y_max * m - b;",
      "    if y_max == 0 {",
      "        return ans;",
      "    }",
      "    ans += (n - (x_max + a - 1) / a) * y_max;",
      "    ans += floor_sum(y_max, a, m, (a - x_max % a) % a);",
      "    ans",
      "}"
    ]
  },
  "input": {
    "prefix": "input",
    "body": [
      "# [rustfmt :: skip ] pub fn readln () -> String {let mut line = String :: new () ; :: std :: io :: stdin () . read_line (& mut line ) . unwrap_or_else (| e | panic ! (\"{}\" , e ) ) ; line }",
      "#[allow(unused_macros)]",
      "macro_rules ! read {(\\$ (\\$ t : tt ) ,*; \\$ n : expr ) => {{let stdin = :: std :: io :: stdin () ; let ret = :: std :: io :: BufRead :: lines (stdin . lock () ) . take (\\$ n ) . map (| line | {let line = line . unwrap () ; let mut it = line . split_whitespace () ; _read ! (it ; \\$ (\\$ t ) ,* ) } ) . collect ::< Vec < _ >> () ; ret } } ; (\\$ (\\$ t : tt ) ,* ) => {{let line = readln () ; let mut it = line . split_whitespace () ; _read ! (it ; \\$ (\\$ t ) ,* ) } } ; }",
      "macro_rules ! _read {(\\$ it : ident ; [char ] ) => {_read ! (\\$ it ; String ) . chars () . collect ::< Vec < _ >> () } ; (\\$ it : ident ; [u8 ] ) => {Vec :: from (_read ! (\\$ it ; String ) . into_bytes () ) } ; (\\$ it : ident ; usize1 ) => {\\$ it . next () . unwrap_or_else (|| panic ! (\"input mismatch\" ) ) . parse ::< usize > () . unwrap_or_else (| e | panic ! (\"{}\" , e ) ) - 1 } ; (\\$ it : ident ; [usize1 ] ) => {\\$ it . map (| s | s . parse ::< usize > () . unwrap_or_else (| e | panic ! (\"{}\" , e ) ) - 1 ) . collect ::< Vec < _ >> () } ; (\\$ it : ident ; [\\$ t : ty ] ) => {\\$ it . map (| s | s . parse ::<\\$ t > () . unwrap_or_else (| e | panic ! (\"{}\" , e ) ) ) . collect ::< Vec < _ >> () } ; (\\$ it : ident ; \\$ t : ty ) => {\\$ it . next () . unwrap_or_else (|| panic ! (\"input mismatch\" ) ) . parse ::<\\$ t > () . unwrap_or_else (| e | panic ! (\"{}\" , e ) ) } ; (\\$ it : ident ; \\$ (\\$ t : tt ) ,+ ) => {(\\$ (_read ! (\\$ it ; \\$ t ) ) ,* ) } ; }"
    ]
  },
  "scanner": {
    "prefix": "scanner",
    "body": [
      "#[allow(dead_code)]",
      "pub mod scanner {",
      "    use std;",
      "    use std::io::Read;",
      "    use std::str::FromStr;",
      "    use std::str::SplitWhitespace;",
      "    pub struct Scanner<'a> {",
      "        it: SplitWhitespace<'a>,",
      "    }",
      "    impl<'a> Scanner<'a> {",
      "        pub fn new(s: &'a str) -> Scanner<'a> {",
      "            Scanner {",
      "                it: s.split_whitespace(),",
      "            }",
      "        }",
      "        pub fn nxt<T: FromStr>(&mut self) -> T {",
      "            match self.it.next().unwrap().parse::<T>() {",
      "                Ok(v) => v,",
      "                _ => panic!(\"Scanner error\"),",
      "            }",
      "        }",
      "        pub fn nxt_chars(&mut self) -> Vec<char> {",
      "            self.nxt::<String>().chars().collect()",
      "        }",
      "        pub fn nxt_vec<T: FromStr>(&mut self, len: usize) -> Vec<T> {",
      "            (0..len).map(|_| self.nxt()).collect()",
      "        }",
      "    }",
      "    pub fn read_string() -> String {",
      "        let mut s = String::new();",
      "        std::io::stdin().read_to_string(&mut s).unwrap();",
      "        s",
      "    }",
      "}"
    ]
  },
  "sieves": {
    "prefix": "sieves",
    "body": [
      "pub struct Sieve {",
      "    f: Vec<usize>,",
      "    primes: Vec<usize>,",
      "}",
      "impl Sieve {",
      "    pub fn new(max_n: usize) -> Self {",
      "        let mut f = vec![0; max_n + 1];",
      "        let mut primes = Vec::new();",
      "        for i in 2..=max_n {",
      "            if f[i] > 0 {",
      "                continue;",
      "            }",
      "            primes.push(i);",
      "            f[i] = i;",
      "            for j in i..=max_n / i {",
      "                if f[i * j] == 0 {",
      "                    f[i * j] = i;",
      "                }",
      "            }",
      "        }",
      "        Sieve { f, primes }",
      "    }",
      "    pub fn is_prime(&self, x: usize) -> bool {",
      "        self.f[x] == x",
      "    }",
      "    /// Example:",
      "    ///   let mut fl = Vec::new();",
      "    ///   seive.factor_list(90, &mut fl);",
      "    ///   => fl = [2, 3, 3, 5]",
      "    pub fn factor_list(&self, x: usize, fl: &mut Vec<usize>) {",
      "        if !fl.is_empty() {",
      "            panic!(\"fl must be empty\");",
      "        }",
      "        let mut x = x;",
      "        while x != 1 {",
      "            fl.push(self.f[x]);",
      "            x /= self.f[x];",
      "        }",
      "    }",
      "    /// Example:",
      "    ///   let mut f = Vec::new();",
      "    ///   seive.factor(90, &mut f);",
      "    ///   => f = [(2, 1), (3, 2), (5, 1)]",
      "    pub fn factor(&self, x: usize, f: &mut Vec<(usize, usize)>) {",
      "        if !f.is_empty() {",
      "            panic!(\"f must be empty\");",
      "        }",
      "        let mut fl = Vec::new();",
      "        self.factor_list(x, &mut fl);",
      "        if fl.is_empty() {",
      "            return;",
      "        }",
      "        let mut p_prev = fl[0];",
      "        let mut count = 0;",
      "        for p in fl {",
      "            if p == p_prev {",
      "                count += 1;",
      "            } else {",
      "                f.push((p_prev, count));",
      "                p_prev = p;",
      "                count = 1;",
      "            }",
      "        }",
      "        f.push((p_prev, count));",
      "    }",
      "    pub fn get_primes(&self) -> Vec<usize> {",
      "        self.primes.clone()",
      "    }",
      "}"
    ]
  }
}
