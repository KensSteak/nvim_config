snippet     v
abbr        Vector<T>
options     head
  let mut ${1:name} = vec![${2}];

snippet     lm
abbr        let mut
options     head
  let mut ${1:#:x} = ${2:target};

snippet     heap
abbr        BinaryHeap
options     head
  let mut ${1:q} = BinaryHeap::<${2:_}>::new();${0:Target}

snippet     bset
abbr        BTreeSet
options     head
  let mut ${1:set} = BTreeSet::<${2:_}>::new();${0:Target}

snippet     hset
abbr        HashSet
options     head
  let mut ${1:set} = HashSet::<${2:_}>::new();${0:Target}

snippet     bmap
abbr        BTreeMap
options     head
  let mut ${1:map} = BTreeMap::<${2:_}, ${3:_}>::new();${0:Target}

snippet     hmap
abbr        HashMap
options     head
  let mut ${1:map} = HashMap::<${2:_}, ${3:_}>::new();${0:Target}

snippet     entry
abbr        entry api
options     head
  ${1:#}.entry(${2:#}).or_insert(${3:#})

snippet     que
abbr        VecDeque
options     head
  let mut ${1:q} = VecDeque::<${2:_}>::new();${0:Target}

snippet     in
abbr        input! macro
options     head
  input! {
      ${1:#:el}: ${2:#:type}
  }

snippet     p
abbr        print! 1 expr
options     head
  print!("${1:{}}", ${2:#:x});

snippet     pl
abbr        println! 1 expr
options     head
  println!("{}", ${1:#:x});

snippet     ps
abbr        println! string
options     head
  println!("${1:#:str}");

snippet     w
abbr        write
options     head
  write!(out, "{}", ${1:#:x}).unwrap();

snippet     wl
abbr        writeln
options     head
  writeln!(out, "{}", ${1:#:x}).unwrap();

snippet     ws
abbr        writeln! string
options     head
  writeln!(out, "${1:#:str}").unwrap();

snippet     fi
abbr        input! macro
options     head
  for &${1:#:e} in ${2:#:v}.iter() {
      ${0:Target}
  }

snippet     fe
abbr        input! macro
options     head
  for (i, &${1:#:e}) in ${2:#:v}.iter().enumerate() {
      ${0:Target}
  }

snippet     dfs
abbr        dfs base
options     head
  fn dfs(v: usize, p: usize, to: &Vec<Vec<usize>>) {
      for &u in to[v].iter() {
          if u == p {
              continue;
          }
          dfs(u, v, to);
      }
  }

snippet     time_macro
abbr        measure time macro
options     head
  use std::time::Instant;
  macro_rules! measure {
      ( $x:expr) => {{
          let start = Instant::now();
          let result = $x;
          let end = start.elapsed();
          println!(
              "[{0}:{1}] {2}\n>> elapsed: {3:.6} sec",
              file!(),
              line!(),
              stringify!($x),
              end.as_secs_f64(),
          );
          result
      }};
  }${0:Target}

snippet     binary_search_macro
abbr        binary search function
options     head
  fn binary_search<R, F: Fn(${1:i64}) -> bool>(range: R, condition: F) -> $1
  where
      R: std::ops::RangeBounds<$1>,
  {
      let mut low = match range.start_bound() {
          std::ops::Bound::Included(&a) => a,
          _ => unreachable!(),
      };
      let mut high = match range.end_bound() {
          std::ops::Bound::Excluded(&a) => a,
          std::ops::Bound::Included(&a) => a + 1,
          _ => unreachable!(),
      };
      assert!(condition(low));
      while high - low > 1 {
          let mid = (low + high) / 2;
          if condition(mid) {
              low = mid;
          } else {
              high = mid;
          }
      }
      return low;
  }
